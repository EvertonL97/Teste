<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Quest - RPG Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --ff-blue: #040494;
            --ff-gold: #f1c40f;
            --ff-green: #2ecc71;
            --ff-red: #e74c3c;
            --ff-purple: #9b59b6;
        }

        body {
            background: #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            line-height: 1.6;
            image-rendering: pixelated;
            overflow-x: hidden;
        }

        /* Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9999;
        }

        /* Container */
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Window Styles */
        .window {
            background: linear-gradient(180deg, var(--ff-blue) 0%, #000044 100%);
            border: 3px solid #fff;
            border-radius: 6px;
            padding: 20px;
            box-shadow: 4px 4px 0px #000;
            margin-bottom: 20px;
        }

        .window-red {
            background: linear-gradient(180deg, #940404 0%, #440000 100%);
        }

        /* Button */
        .btn {
            background: rgba(0,0,0,0.6);
            border: 2px solid #666;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            padding: 12px 16px;
            width: 100%;
            transition: all 0.1s steps(2);
            margin-bottom: 8px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .btn:focus-visible {
            outline: 3px solid var(--ff-gold);
            outline-offset: 2px;
        }

        .btn:hover:not(:disabled) {
            color: var(--ff-gold);
            background: rgba(255,255,255,0.1);
            border-color: var(--ff-gold);
            transform: translateX(4px);
        }

        .btn:active:not(:disabled) {
            transform: translateX(2px) translateY(2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading state */
        .btn.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            right: 12px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Skip to content link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: var(--ff-blue);
            color: white;
            padding: 8px;
            text-decoration: none;
            z-index: 100;
            border-radius: 4px;
        }

        .skip-link:focus {
            top: 6px;
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .btn {
                border-width: 3px;
            }
            
            .window {
                border-width: 4px;
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #333;
        }

        /* Input */
        .input {
            background: rgba(0,0,0,0.4);
            border: 2px solid #fff;
            color: var(--ff-gold);
            font-family: 'Press Start 2P', cursive;
            padding: 12px;
            width: 100%;
            margin-bottom: 15px;
            outline: none;
            font-size: 12px;
            text-align: center;
            text-transform: uppercase;
        }

        .input:focus {
            border-color: var(--ff-gold);
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.3);
        }

        /* Text Styles */
        .text-gold { color: var(--ff-gold); }
        .text-green { color: var(--ff-green); }
        .text-red { color: var(--ff-red); }
        .text-purple { color: var(--ff-purple); }
        .text-center { text-align: center; }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-stat {
            font-size: 10px;
            color: #999;
        }

        .header-value {
            font-size: 16px;
            display: block;
        }

        /* Stats Panel */
        .stats-panel {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border: 2px solid #666;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 10px;
        }

        .hp-bar, .limit-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 2px solid #666;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--ff-green), #1abc9c);
            transition: width 0.3s;
        }

        .limit-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--ff-purple), #e74c3c);
            transition: width 0.3s;
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8px;
            text-shadow: 1px 1px 2px #000;
            z-index: 1;
        }

        /* Battle Arena */
        .battle-arena {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 40px 20px;
            min-height: 300px;
        }

        /* Yu-Gi-Oh Card Style */
        .card {
            width: 140px;
            height: 200px;
            background: linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 100%);
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.5),
                inset 0 -1px 0 rgba(0,0,0,0.2);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            transition: all 0.3s ease;
        }

        .card.hero-card {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            border-color: #2c5aa0;
            box-shadow: 
                0 4px 12px rgba(74, 144, 226, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3),
                inset 0 -1px 0 rgba(0,0,0,0.3);
        }

        .card.enemy-card {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border-color: #a93226;
            box-shadow: 
                0 4px 12px rgba(231, 76, 60, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.3),
                inset 0 -1px 0 rgba(0,0,0,0.3);
        }

        .card.boss-card {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            border-color: #7d3c98;
            box-shadow: 
                0 6px 16px rgba(155, 89, 182, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.4),
                inset 0 -1px 0 rgba(0,0,0,0.4);
            transform: scale(1.1);
        }

        .card.active {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 
                0 8px 20px rgba(255, 215, 0, 0.6),
                inset 0 1px 0 rgba(255,255,255,0.5),
                inset 0 -1px 0 rgba(0,0,0,0.3);
            border-color: #ffd700;
        }

        .card-emoji {
            font-size: 48px;
            margin: 10px 0;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .card-name {
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            margin-bottom: 5px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.6);
            padding: 2px 6px;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        .card-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 4px;
            margin-top: auto;
        }

        .card-stat {
            font-size: 9px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .card-stat.atk {
            color: #e74c3c;
        }

        .card-stat.def {
            color: #3498db;
        }

        .card-hp-bar {
            width: 100%;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            margin: 4px 0;
            overflow: hidden;
        }

        .card-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .card-hp-text {
            font-size: 7px;
            color: #fff;
            text-align: center;
            margin-top: 2px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Small Card Styles */
        .card.small-card {
            width: 100px;
            height: 140px;
            padding: 6px;
        }

        .small-emoji {
            font-size: 32px !important;
            margin: 6px 0;
        }

        .small-name {
            font-size: 8px !important;
            margin-bottom: 3px !important;
        }

        .small-hp-bar {
            width: 100% !important;
            height: 4px !important;
            margin: 3px 0 !important;
        }

        .small-hp-text {
            font-size: 6px !important;
            margin-top: 1px !important;
        }

        .small-stats {
            padding: 2px 4px !important;
            margin-top: auto !important;
        }

        .small-stat {
            font-size: 7px !important;
        }

        /* Multiple Enemies Layout */
        .battle-arena.multiple-enemies {
            flex-direction: column;
            gap: 20px;
        }

        .enemies-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            max-width: 400px;
        }

        .enemy-card-wrapper {
            position: relative;
            flex-shrink: 0;
        }

        .card-stat.hp {
            color: #e74c3c;
        }

        /* Card Animations */
        .card.attacking {
            animation: cardAttack 1.2s ease-in-out;
        }

        .card.damaged {
            animation: cardDamage 0.5s ease-in-out;
        }

        .card.healing {
            animation: cardHeal 0.8s ease-in-out;
        }

        .card.card-attack-hit {
            animation: cardAttackHit 0.7s ease-in-out;
        }

        @keyframes cardAttack {
            0% { transform: translateX(0) translateY(0) scale(1) rotate(0deg); z-index: 10; }
            15% { transform: translateX(60px) translateY(-15px) scale(1.1) rotate(3deg); z-index: 15; }
            30% { transform: translateX(120px) translateY(-25px) scale(1.2) rotate(5deg); z-index: 20; }
            45% { transform: translateX(180px) translateY(-20px) scale(1.3) rotate(2deg); z-index: 25; }
            60% { transform: translateX(240px) translateY(-10px) scale(1.4) rotate(0deg); z-index: 30; }
            75% { transform: translateX(200px) translateY(5px) scale(1.3) rotate(-2deg); z-index: 25; }
            90% { transform: translateX(100px) translateY(5px) scale(1.1) rotate(-1deg); z-index: 15; }
            100% { transform: translateX(0) translateY(0) scale(1) rotate(0deg); z-index: 10; }
        }

        @keyframes cardAttackHit {
            0% { transform: translateX(0) translateY(0) scale(1); }
            10% { transform: translateX(-5px) translateY(-5px) scale(0.95) rotate(-5deg); }
            20% { transform: translateX(5px) translateY(5px) scale(1.05) rotate(5deg); }
            30% { transform: translateX(-3px) translateY(-3px) scale(0.98) rotate(-3deg); }
            40% { transform: translateX(3px) translateY(3px) scale(1.02) rotate(3deg); }
            50% { transform: translateX(-1px) translateY(-1px) scale(0.99) rotate(-1deg); }
            60% { transform: translateX(1px) translateY(1px) scale(1.01) rotate(1deg); }
            70% { transform: translateX(0) translateY(0) scale(1) rotate(0deg); }
        }

        @keyframes cardDamage {
            0%, 100% { transform: translateX(0); filter: brightness(1); }
            25% { transform: translateX(-10px); filter: brightness(1.5) hue-rotate(180deg); }
            50% { transform: translateX(10px); filter: brightness(2) hue-rotate(90deg); }
            75% { transform: translateX(-5px); filter: brightness(1.5) hue-rotate(45deg); }
        }

        @keyframes cardHeal {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5) hue-rotate(120deg); }
        }

        .sprite {
            font-size: 80px;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.5));
            transition: transform 0.2s;
        }

        .sprite.active {
            animation: bounce 0.5s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .vs-text {
            font-size: 24px;
            color: var(--ff-red);
            font-weight: bold;
        }

        /* Battle Controls */
        .battle-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        /* Log */
        .log {
            background: rgba(0,0,0,0.5);
            border: 2px solid #666;
            padding: 15px;
            height: 120px;
            overflow-y: auto;
            font-size: 10px;
            line-height: 1.8;
        }

        .log-entry {
            margin-bottom: 5px;
            color: #999;
        }

        .log-entry:first-child {
            color: #fff;
            font-weight: bold;
        }

        .log-entry::before {
            content: '> ';
            color: var(--ff-gold);
        }

        /* Screen Management */
        .screen {
            display: none;
        }

        .screen.active {
            display: block;
        }

        /* Shop Grid */
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Home Screen */
        .home-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, rgba(4, 4, 148, 0.2), transparent 70%);
        }

        .home-window {
            max-width: 500px;
        }

        .title {
            font-size: 32px;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 4px 4px 0 #000;
        }

        .subtitle {
            text-align: center;
            font-size: 8px;
            color: #999;
            letter-spacing: 2px;
            margin-bottom: 30px;
        }

        /* Victory/Game Over */
        .result-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            text-align: center;
        }

        .result-icon {
            font-size: 100px;
            margin: 20px 0;
        }

        .result-title {
            font-size: 28px;
            margin-bottom: 10px;
        }

        /* Utility */
        .mb-4 { margin-bottom: 20px; }
        .mt-4 { margin-top: 20px; }
        .hidden { display: none !important; }

        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .title { font-size: 24px; }
            .sprite { font-size: 60px; }
            .battle-controls { grid-template-columns: 1fr; }
        }

        /* Pulse Animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        /* Game Grid */
        .game-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        @media (max-width: 968px) {
            .game-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Anima√ß√µes de combate melhoradas */
        @keyframes attack {
            0% { transform: translateX(0) scale(1); }
            30% { transform: translateX(30px) scale(1.2); }
            60% { transform: translateX(-10px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes damage {
            0%, 100% { filter: brightness(1) hue-rotate(0deg); }
            25% { filter: brightness(2) hue-rotate(180deg) saturate(2); }
            50% { filter: brightness(1.5) hue-rotate(90deg); }
            75% { filter: brightness(1.8) hue-rotate(270deg); }
        }

        @keyframes heal {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 0 transparent); }
            50% { filter: brightness(1.5) drop-shadow(0 0 20px #2ecc71); }
        }

        @keyframes floatUp {
            0% { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% { 
                transform: translateY(-60px) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Classes de anima√ß√£o */
        .attacking { animation: attack 0.6s ease-out; }
        .damaged { animation: damage 0.5s ease-out; }
        .healing { animation: heal 0.8s ease-out; }
        .shaking { animation: shake 0.3s ease-out; }

        /* Part√≠culas flutuantes */
        .damage-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1.5s ease-out forwards;
        }

        .damage-number.critical {
            color: #ff6b6b;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .damage-number.normal {
            color: #ffd93d;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .heal-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #2ecc71;
            pointer-events: none;
            z-index: 1000;
            animation: floatUp 1.5s ease-out forwards;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Efeito de brilho para bot√µes */
        .btn.glowing {
            box-shadow: 0 0 20px rgba(241, 196, 15, 0.6);
            border-color: var(--ff-gold);
        }

        /* Efeitos especiais para chefes */
        .boss-warning {
            animation: bossPulse 1s infinite;
        }

        @keyframes bossPulse {
            0%, 100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.8));
            }
            50% { 
                transform: scale(1.1);
                filter: drop-shadow(0 0 20px rgba(255, 0, 0, 1));
            }
        }

        .sprite.boss {
            font-size: 100px;
            filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.6));
        }

        .sprite.boss.active {
            animation: bossBounce 0.8s infinite;
        }

        @keyframes bossBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-15px) scale(1.1); }
            50% { transform: translateY(-8px) scale(1.05); }
            75% { transform: translateY(-12px) scale(1.08); }
        }

        /* Indicador de m√∫ltiplos inimigos */
        .enemy-count {
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--ff-red);
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 2px solid white;
        }

        /* Sprites personalizados */
        .sprite-custom {
            width: 64px;
            height: 64px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .sprite-hero {
            background-image: url('imagens/Guerreiro.png');
        }

        .sprite-slime {
            background-image: url('imagens/Slime.png');
        }

        .sprite-goblin {
            background-image: url('imagens/Goblin.png');
        }

        .sprite-wolf {
            background-image: url('imagens/Lobo.png');
        }

        /* Anima√ß√µes para sprites */
        .sprite-custom.attacking {
            animation: spriteAttack 0.6s ease-in-out;
        }

        .sprite-custom.damaged {
            animation: spriteDamage 0.5s ease-in-out;
        }

        .sprite-custom.healing {
            animation: spriteHeal 0.8s ease-in-out;
        }

        @keyframes spriteAttack {
            0% { transform: translateX(0) scale(1); }
            30% { transform: translateX(20px) scale(1.2); }
            60% { transform: translateX(-5px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes spriteDamage {
            0%, 100% { transform: translateX(0); filter: brightness(1); }
            25% { transform: translateX(-5px); filter: brightness(1.5) hue-rotate(180deg); }
            75% { transform: translateX(5px); filter: brightness(1.5) hue-rotate(180deg); }
        }

        @keyframes spriteHeal {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.5) hue-rotate(120deg); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        /* Barra de XP */
        .xp-bar {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .xp-fill {
            background: linear-gradient(90deg, #f1c40f, #f39c12);
            height: 100%;
            transition: width 0.5s ease-in-out;
            border-radius: 3px;
            box-shadow: 0 0 5px rgba(241, 196, 15, 0.5);
        }

        /* Transi√ß√µes suaves entre telas */
        .screen {
            transition: opacity 0.3s ease-in-out;
        }

        .screen.fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        // ============================================
        // GAME STATE & CONSTANTS
        // ============================================
        
        // Sistema de sprites personalizados
        const SPRITE_MAP = {
            '‚öîÔ∏è': { class: 'sprite-hero', fallback: '‚öîÔ∏è' },
            'üíß': { class: 'sprite-slime', fallback: 'üíß' },
            'üë∫': { class: 'sprite-goblin', fallback: 'üë∫' },
            'ü¶á': { class: '', fallback: 'ü¶á' },
            'üíÄ': { class: '', fallback: 'üíÄ' },
            'üëπ': { class: '', fallback: 'üëπ' },
            'ü•∑': { class: '', fallback: 'ü•∑' },
            'üëø': { class: '', fallback: 'üëø' },
            'üê≤': { class: '', fallback: 'üê≤' },
            'üßü‚Äç‚ôÇÔ∏è': { class: '', fallback: 'üßü‚Äç‚ôÇÔ∏è' }
        };

        // Fun√ß√£o para renderizar sprite
        function renderSprite(sprite, isCustom = false) {
            if (isCustom && SPRITE_MAP[sprite]) {
                const spriteData = SPRITE_MAP[sprite];
                if (spriteData.class) {
                    return `<div class="sprite-custom ${spriteData.class}"></div>`;
                }
            }
            return sprite;
        }

        // Fun√ß√£o para renderizar carta estilo Yu-Gi-Oh
        function renderCard(character, type = 'hero', isActive = false, gameInstance = null, size = 'normal') {
            const game = gameInstance || window.game;
            const totalStats = (game && type === 'hero') ? game.getTotalStats() : { atk: character.atk, def: character.def };
            const hpPercent = (character.hp / character.maxHp) * 100;
            
            const cardClass = `card ${type}-card ${isActive ? 'active' : ''} ${size === 'small' ? 'small-card' : ''}`;
            let emoji, name;
            
            if (type === 'hero') {
                const classData = CLASS_SYSTEM[character.class] || CLASS_SYSTEM.aprendiz;
                emoji = classData.icon;
                name = classData.name;
            } else {
                emoji = character.sprite;
                name = character.name;
            }
            
            // Para monstros, mostrar HP e ATK. Para her√≥i, mostrar HP e ATK/DEF
            const showMonsterStats = type !== 'hero';
            
            return `
                <div class="${cardClass}">
                    <div class="card-emoji ${size === 'small' ? 'small-emoji' : ''}">${emoji}</div>
                    <div class="card-name ${size === 'small' ? 'small-name' : ''}">${name}</div>
                    <div class="card-hp-bar ${size === 'small' ? 'small-hp-bar' : ''}">
                        <div class="card-hp-fill" style="width: ${hpPercent}%"></div>
                    </div>
                    <div class="card-hp-text ${size === 'small' ? 'small-hp-text' : ''}">${character.hp}/${character.maxHp}</div>
                    <div class="card-stats ${size === 'small' ? 'small-stats' : ''}">
                        ${showMonsterStats ? `
                            <div class="card-stat atk ${size === 'small' ? 'small-stat' : ''}">
                                ‚öîÔ∏è ${totalStats.atk}
                            </div>
                            <div class="card-stat hp ${size === 'small' ? 'small-stat' : ''}">
                                ‚ù§Ô∏è ${character.maxHp}
                            </div>
                        ` : `
                            <div class="card-stat atk ${size === 'small' ? 'small-stat' : ''}">
                                ‚öîÔ∏è ${totalStats.atk}
                            </div>
                            <div class="card-stat def ${size === 'small' ? 'small-stat' : ''}">
                                üõ°Ô∏è ${totalStats.def}
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        // Sistema de Classes
        const CLASS_SYSTEM = {
            aprendiz: {
                name: "Aprendiz",
                icon: "üéì",
                baseStats: { hp: 100, atk: 10, def: 5 },
                growthRates: { hp: 8, atk: 2, def: 1 },
                description: "Um jovem aventureiro em busca de conhecimento.",
                skills: []
            },
            guerreiro: {
                name: "Guerreiro",
                icon: "‚öîÔ∏è",
                baseStats: { hp: 150, atk: 15, def: 10 },
                growthRates: { hp: 12, atk: 3, def: 2 },
                description: "Mestre das armas, especializado em combate corpo a corpo.",
                skills: ["golpe_poderoso", "defesa_firme"]
            },
            mago: {
                name: "Mago",
                icon: "üßô‚Äç‚ôÇÔ∏è",
                baseStats: { hp: 80, atk: 20, def: 3 },
                growthRates: { hp: 6, atk: 4, def: 1 },
                description: "Dominador das artes arcanas e magias poderosas.",
                skills: ["bola_fogo", "escudo_magico"]
            },
            ladrao: {
                name: "Ladr√£o",
                icon: "üó°Ô∏è",
                baseStats: { hp: 90, atk: 18, def: 6 },
                growthRates: { hp: 7, atk: 3.5, def: 1.5 },
                description: "√Ågil e furtivo, especialista em ataques cr√≠ticos.",
                skills: ["ataque_furtivo", "esquiva_perfeita"]
            },
            // Evolu√ß√µes N√≠vel 20
            paladino: {
                name: "Paladino",
                icon: "üõ°Ô∏è",
                baseStats: { hp: 200, atk: 18, def: 15 },
                growthRates: { hp: 15, atk: 3.5, def: 3 },
                description: "Guerreiro sagrado, protetor dos inocentes.",
                skills: ["golpe_poderoso", "defesa_firme", "cura_divina"],
                evolvesFrom: "guerreiro"
            },
            cavaleiro: {
                name: "Cavaleiro",
                icon: "üèá",
                baseStats: { hp: 180, atk: 22, def: 12 },
                growthRates: { hp: 13, atk: 4, def: 2.5 },
                description: "Guerreiro montado, mestre da carga.",
                skills: ["golpe_poderoso", "defesa_firme", "carga_devastadora"],
                evolvesFrom: "guerreiro"
            },
            arcanista: {
                name: "Arcanista",
                icon: "üîÆ",
                baseStats: { hp: 100, atk: 28, def: 5 },
                growthRates: { hp: 8, atk: 5, def: 1.5 },
                description: "Mestre supremo das artes arcanas.",
                skills: ["bola_fogo", "escudo_magico", "meteoro"],
                evolvesFrom: "mago"
            },
            necromante: {
                name: "Necromante",
                icon: "üíÄ",
                baseStats: { hp: 90, atk: 25, def: 4 },
                growthRates: { hp: 7, atk: 4.5, def: 1 },
                description: "Controlador das for√ßas das trevas.",
                skills: ["bola_fogo", "escudo_magico", "ressurreicao"],
                evolvesFrom: "mago"
            },
            assassino: {
                name: "Assassino",
                icon: "üó°Ô∏è",
                baseStats: { hp: 110, atk: 25, def: 8 },
                growthRates: { hp: 8, atk: 4, def: 2 },
                description: "Mestre da furtividade e ataques mortais.",
                skills: ["ataque_furtivo", "esquiva_perfeita", "golpe_mortal"],
                evolvesFrom: "ladrao"
            },
            ninja: {
                name: "Ninja",
                icon: "ü•∑",
                baseStats: { hp: 100, atk: 23, def: 10 },
                growthRates: { hp: 7.5, atk: 4, def: 2.5 },
                description: "Agente sombrio, mestre das artes ninja.",
                skills: ["ataque_furtivo", "esquiva_perfeita", "clone_sombrio"],
                evolvesFrom: "ladrao"
            },
            // Evolu√ß√µes N√≠vel 40
            cavaleiro_sagrado: {
                name: "Cavaleiro Sagrado",
                icon: "‚ú®",
                baseStats: { hp: 300, atk: 25, def: 25 },
                growthRates: { hp: 20, atk: 4, def: 4 },
                description: "Lend√°rio campe√£o da luz e justi√ßa.",
                skills: ["golpe_poderoso", "defesa_firme", "cura_divina", "julgamento_divino"],
                evolvesFrom: "paladino"
            },
            mestre_guerra: {
                name: "Mestre de Guerra",
                icon: "‚öîÔ∏è",
                baseStats: { hp: 280, atk: 30, def: 20 },
                growthRates: { hp: 18, atk: 5, def: 3.5 },
                description: "Lend√°rio estrategista e guerreiro.",
                skills: ["golpe_poderoso", "defesa_firme", "carga_devastadora", "dominio_batalha"],
                evolvesFrom: "cavaleiro"
            },
            arqui_mago: {
                name: "Arqui-Mago",
                icon: "üåü",
                baseStats: { hp: 150, atk: 40, def: 10 },
                growthRates: { hp: 10, atk: 6, def: 2 },
                description: "Ser lend√°rio, mestre de toda magia.",
                skills: ["bola_fogo", "escudo_magico", "meteoro", "apocalipse"],
                evolvesFrom: "arcanista"
            },
            lorde_das_trevas: {
                name: "Senhor das Trevas",
                icon: "üåë",
                baseStats: { hp: 130, atk: 35, def: 8 },
                growthRates: { hp: 9, atk: 5.5, def: 1.5 },
                description: "Lend√°rio controlador do poder obscuro.",
                skills: ["bola_fogo", "escudo_magico", "ressurreicao", "dominio_sombrio"],
                evolvesFrom: "necromante"
            },
            mestre_assassino: {
                name: "Mestre Assassino",
                icon: "üéØ",
                baseStats: { hp: 160, atk: 35, def: 12 },
                growthRates: { hp: 10, atk: 5, def: 2.5 },
                description: "Lend√°rio matador sombrio.",
                skills: ["ataque_furtivo", "esquiva_perfeita", "golpe_mortal", "morte_instantanea"],
                evolvesFrom: "assassino"
            },
            mestre_ninja: {
                name: "Mestre Ninja",
                icon: "üåô",
                baseStats: { hp: 150, atk: 32, def: 15 },
                growthRates: { hp: 9.5, atk: 5, def: 3 },
                description: "Lend√°rio mestre das artes sombrias.",
                skills: ["ataque_furtivo", "esquiva_perfeita", "clone_sombrio", "teleporte_sombrio"],
                evolvesFrom: "ninja"
            }
        };

        const INITIAL_HERO = {
            name: "Hero",
            hp: 100,
            maxHp: 100,
            atk: 10,
            def: 5,
            level: 1,
            maxLevel: 50,
            exp: 0,
            gold: 100,
            potions: 3,
            class: "aprendiz",
            classHistory: ["aprendiz"],
            hasDefeatedFirstBoss: false,
            skills: [],
            equipment: {
                weapon: null,
                armor: null,
                accessory: null
            },
            buffs: [],
            debuffs: [],
            limitBreak: 0
        };

        const ENEMIES = [
            { 
                name: "Slime", 
                hp: 30, 
                maxHp: 30, 
                atk: 5, 
                exp: 10, 
                gold: 5, 
                sprite: "üíß",
                element: "water",
                resistances: { water: 0.5, fire: 1.5 },
                weaknesses: ["lightning"],
                statusImmune: ["freeze"]
            },
            { 
                name: "Bat", 
                hp: 25, 
                maxHp: 25, 
                atk: 8, 
                exp: 15, 
                gold: 8, 
                sprite: "ü¶á",
                element: "dark",
                resistances: { dark: 0.3, light: 1.5 },
                weaknesses: ["light"],
                statusImmune: ["stun"]
            },
            { 
                name: "Goblin", 
                hp: 60, 
                maxHp: 60, 
                atk: 12, 
                exp: 25, 
                gold: 15, 
                sprite: "üë∫",
                element: "earth",
                resistances: { earth: 0.4, lightning: 1.3 },
                weaknesses: ["water"],
                statusImmune: ["poison"]
            },
            { 
                name: "Skeleton", 
                hp: 80, 
                maxHp: 80, 
                atk: 15, 
                exp: 35, 
                gold: 20, 
                sprite: "üíÄ",
                element: "dark",
                resistances: { dark: 0.5, light: 1.8, physical: 0.7 },
                weaknesses: ["lightning", "fire"],
                statusImmune: ["poison", "bleed"]
            },
            { 
                name: "Orc", 
                hp: 100, 
                maxHp: 100, 
                atk: 18, 
                exp: 45, 
                gold: 25, 
                sprite: "üëπ",
                element: "fire",
                resistances: { fire: 0.4, water: 1.4 },
                weaknesses: ["water", "nature"],
                statusImmune: ["burn"]
            },
            { 
                name: "Dark Knight", 
                hp: 120, 
                maxHp: 120, 
                atk: 22, 
                exp: 55, 
                gold: 30, 
                sprite: "ü•∑",
                element: "dark",
                resistances: { dark: 0.3, light: 1.6, physical: 0.5 },
                weaknesses: ["light", "psychic"],
                statusImmune: ["stun", "freeze"]
            }
        ];

        const BOSSES = [
            { 
                name: "Demon Lord", 
                hp: 500, 
                maxHp: 500, 
                atk: 35, 
                exp: 200, 
                gold: 200, 
                sprite: "üëø",
                element: "fire",
                resistances: { fire: 0.3, water: 1.5, dark: 0.4 },
                weaknesses: ["water", "light"],
                statusImmune: ["burn", "freeze"],
                special: "fire_breath"
            },
            { 
                name: "Ancient Dragon", 
                hp: 600, 
                maxHp: 600, 
                atk: 40, 
                exp: 250, 
                gold: 300, 
                sprite: "üê≤",
                element: "fire",
                resistances: { fire: 0.2, water: 1.8, lightning: 0.8 },
                weaknesses: ["water", "earth"],
                statusImmune: ["burn", "freeze", "stun"],
                special: "tail_swipe"
            },
            { 
                name: "Lich King", 
                hp: 450, 
                maxHp: 450, 
                atk: 38, 
                exp: 220, 
                gold: 250, 
                sprite: "üßü‚Äç‚ôÇÔ∏è",
                element: "dark",
                resistances: { dark: 0.2, light: 2.0, psychic: 0.5, physical: 0.6 },
                weaknesses: ["light", "fire"],
                statusImmune: ["poison", "bleed", "freeze", "stun"],
                special: "life_drain"
            }
        ];

        const SHOP_ITEMS = [
            { id: 'potion', name: 'Po√ß√£o (+50% HP)', cost: 50, type: 'potion' },
            { id: 'upgrade_atk', name: 'Pedra de Amolar (+2 ATK)', cost: 200, type: 'upgrade_atk' },
            { id: 'upgrade_def', name: 'Armadura de Couro (+2 DEF)', cost: 200, type: 'upgrade_def' },
            { id: 'upgrade_hp', name: 'Amuleto da Vida (+20 HP Max)', cost: 300, type: 'upgrade_hp' }
        ];

        // ============================================
        // LOOT SYSTEM
        // ============================================
        const LOOT_TIERS = {
            common: { name: 'Comum', color: '#95a5a6', chance: 0.6, multiplier: 1 },
            uncommon: { name: 'Incomum', color: '#2ecc71', chance: 0.25, multiplier: 1.5 },
            rare: { name: 'Raro', color: '#3498db', chance: 0.1, multiplier: 2 },
            epic: { name: '√âpico', color: '#9b59b6', chance: 0.04, multiplier: 3 },
            legendary: { name: 'Lend√°rio', color: '#f1c40f', chance: 0.01, multiplier: 5 }
        };

        const LOOT_TYPES = {
            gold: { name: 'Ouro', icon: 'ü™ô', baseValue: 10 },
            silver: { name: 'Prata', icon: 'ü•à', baseValue: 5 },
            gem: { name: 'Gema', icon: 'üíé', baseValue: 50 },
            material: { name: 'Material', icon: 'üß™', baseValue: 25 },
            equipment: { name: 'Equipamento', icon: '‚öîÔ∏è', baseValue: 100 },
            consumable: { name: 'Consum√≠vel', icon: 'üß™', baseValue: 30 }
        };

        const MATERIALS = [
            { id: 'slime_goo', name: 'Gosma de Slime', icon: 'üíß', rarity: 'common', value: 5 },
            { id: 'bat_wing', name: 'Asa de Morcego', icon: 'ü¶á', rarity: 'common', value: 8 },
            { id: 'goblin_ear', name: 'Orelha de Goblin', icon: 'üë∫', rarity: 'uncommon', value: 15 },
            { id: 'skeleton_bone', name: 'Osso de Esqueleto', icon: 'üíÄ', rarity: 'uncommon', value: 20 },
            { id: 'orc_tusk', name: 'Presa de Orc', icon: 'üëπ', rarity: 'rare', value: 35 },
            { id: 'dark_essence', name: 'Ess√™ncia Sombria', icon: 'ü•∑', rarity: 'rare', value: 50 },
            { id: 'demon_horn', name: 'Chifre de Dem√¥nio', icon: 'üëø', rarity: 'epic', value: 100 },
            { id: 'dragon_scale', name: 'Escama de Drag√£o', icon: 'üê≤', rarity: 'epic', value: 150 },
            { id: 'lich_phylactery', name: 'Filact√©ria de Lich', icon: 'üßü‚Äç‚ôÇÔ∏è', rarity: 'legendary', value: 300 }
        ];

        const EQUIPMENT = [
            { id: 'rusty_sword', name: 'Espada Enferrujada', type: 'weapon', atk: 2, rarity: 'common', value: 25 },
            { id: 'iron_sword', name: 'Espada de Ferro', type: 'weapon', atk: 5, rarity: 'uncommon', value: 75 },
            { id: 'steel_sword', name: 'Espada de A√ßo', type: 'weapon', atk: 8, rarity: 'rare', value: 150 },
            { id: 'enchanted_blade', name: 'L√¢mina Encantada', type: 'weapon', atk: 12, rarity: 'epic', value: 300 },
            { id: 'legendary_sword', name: 'Espada Lend√°ria', type: 'weapon', atk: 20, rarity: 'legendary', value: 750 },
            { id: 'leather_armor', name: 'Armadura de Couro', type: 'armor', def: 2, rarity: 'common', value: 25 },
            { id: 'iron_armor', name: 'Armadura de Ferro', type: 'armor', def: 5, rarity: 'uncommon', value: 75 },
            { id: 'steel_armor', name: 'Armadura de A√ßo', type: 'armor', def: 8, rarity: 'rare', value: 150 },
            { id: 'enchanted_armor', name: 'Armadura Encantada', type: 'armor', def: 12, rarity: 'epic', value: 300 },
            { id: 'legendary_armor', name: 'Armadura Lend√°ria', type: 'armor', def: 20, rarity: 'legendary', value: 750 }
        ];

        // ============================================
        // CAMP SYSTEM
        // ============================================
        const CAMP_ACTIONS = [
            { id: 'rest', name: 'Descansar Completo', effect: 'full_heal', cost: 0, description: 'Recupera todo o HP' },
            { id: 'meditate', name: 'Medita√ß√£o', effect: 'limit_boost', cost: 0, description: 'Aumenta 30% do Limit Break' },
            { id: 'forge', name: 'Forja R√°pida', effect: 'upgrade_weapon', cost: 100, description: 'Melhora arma temporariamente' },
            { id: 'ritual', name: 'Ritual de Sorte', effect: 'luck_boost', cost: 50, description: 'Aumenta chance de loot raro' },
            { id: 'training', name: 'Treinamento', effect: 'temp_stats', cost: 150, description: '+5 ATK/DEF por 3 batalhas' },
            { id: 'craft', name: 'Crafting', effect: 'open_craft', cost: 0, description: 'Criar itens com materiais' }
        ];

        const CRAFTING_RECIPES = [
            { 
                id: 'health_potion_plus', 
                name: 'Po√ß√£o de Vida+', 
                materials: [{ id: 'slime_goo', amount: 3 }, { id: 'goblin_ear', amount: 1 }],
                result: { type: 'consumable', effect: 'heal', value: 75 }
            },
            { 
                id: 'strength_tonic', 
                name: 'T√¥nico de For√ßa', 
                materials: [{ id: 'orc_tusk', amount: 2 }, { id: 'bat_wing', amount: 3 }],
                result: { type: 'consumable', effect: 'atk_boost', value: 10, duration: 3 }
            },
            { 
                id: 'defense_ointment', 
                name: 'Unguento Defensivo', 
                materials: [{ id: 'skeleton_bone', amount: 2 }, { id: 'slime_goo', amount: 4 }],
                result: { type: 'consumable', effect: 'def_boost', value: 8, duration: 3 }
            },
            { 
                id: 'basic_sword', 
                name: 'Espada B√°sica', 
                materials: [{ id: 'iron_armor', amount: 1 }, { id: 'orc_tusk', amount: 1 }],
                result: { type: 'equipment', atk: 6 }
            }
        ];

        // ============================================
        // MERCHANT SYSTEM
        // ============================================
        const MERCHANT_NAMES = [
            'Gareth o Viajante', 'Elara a Mercadora', 'Barnaby o Trocador',
            'Seraphina a Ex√≥tica', 'Theron o Aventureiro'
        ];

        const MERCHANT_STOCK = [
            { id: 'rare_gem', name: 'Gema Rara', basePrice: 150, type: 'gem', rarity: 'rare' },
            { id: 'health_kit', name: 'Kit de Vida', basePrice: 80, type: 'consumable', effect: 'heal', value: 60 },
            { id: 'strength_scroll', name: 'Pergaminho de For√ßa', basePrice: 120, type: 'consumable', effect: 'atk_boost', value: 8, duration: 5 },
            { id: 'shield_scroll', name: 'Pergaminho de Escudo', basePrice: 100, type: 'consumable', effect: 'def_boost', value: 6, duration: 5 },
            { id: 'luck_charm', name: 'Amuleto da Sorte', basePrice: 200, type: 'consumable', effect: 'luck_boost', value: 1.3, duration: 3 },
            { id: 'merchant_sword', name: 'Espada de Mercador', basePrice: 250, type: 'equipment', atk: 10, rarity: 'uncommon' },
            { id: 'merchant_armor', name: 'Armadura de Mercador', basePrice: 250, type: 'equipment', def: 10, rarity: 'uncommon' }
        ];

        // ============================================
        // POST-BATTLE PATH SYSTEM
        // ============================================
        const PATH_TYPES = {
            combat: {
                name: 'Combate',
                icon: '‚öîÔ∏è',
                description: 'Encontre mais inimigos',
                color: '#e74c3c',
                weight: 40,
                rewards: ['exp', 'gold', 'materials']
            },
            treasure: {
                name: 'Tesouro',
                icon: 'üì¶',
                description: 'Um ba√∫ misterioso',
                color: '#f1c40f',
                weight: 25,
                rewards: ['gold', 'items']
            },
            empty: {
                name: 'Vazio',
                icon: '‚ùå',
                description: 'Nada por aqui...',
                color: '#666',
                weight: 20,
                rewards: []
            },
            healing: {
                name: 'Fonte de Cura',
                icon: 'üíö',
                description: 'Recupere sua sa√∫de',
                color: '#2ecc71',
                weight: 10,
                rewards: ['heal']
            },
            mystery: {
                name: 'Mist√©rio',
                icon: '‚ùì',
                description: 'Algo estranho...',
                color: '#9b59b6',
                weight: 5,
                rewards: ['random']
            }
        };

        const PATH_REWARDS = {
            combat: {
                gold: { min: 20, max: 50 },
                exp: { min: 15, max: 35 },
                materials: { chance: 0.6, amount: 1 }
            },
            treasure: {
                gold: { min: 50, max: 150 },
                items: { chance: 0.8, rarity: ['common', 'uncommon', 'rare'] }
            },
            healing: {
                heal: { percentage: 0.5 }
            },
            mystery: {
                random: { 
                    outcomes: [
                        { type: 'gold', amount: 100 },
                        { type: 'item', rarity: 'rare' },
                        { type: 'heal', percentage: 0.8 },
                        { type: 'damage', percentage: 0.2 }
                    ]
                }
            }
        };

        // ============================================
        // EXPERIENCE SYSTEM
        // ============================================
        const XP_CURVE = {
            // XP necess√°rio para cada n√≠vel (f√≥rmula: level * 100 * 1.2^(level-1))
            getRequiredXP: (level) => {
                if (level <= 1) return 0;
                return Math.floor(level * 100 * Math.pow(1.2, level - 1));
            },
            
            // XP total acumulado at√© o n√≠vel
            getTotalXP: (level) => {
                let total = 0;
                for (let i = 1; i < level; i++) {
                    total += XP_CURVE.getRequiredXP(i + 1);
                }
                return total;
            }
        };

        const LEVEL_REWARDS = {
            1: { 
                message: "Bem-vindo √† aventura!",
                rewards: { hp: 0, atk: 0, def: 0, potions: 3 }
            },
            2: { 
                message: "Voc√™ est√° ficando mais forte!",
                rewards: { hp: 10, atk: 1, def: 1, potions: 1 }
            },
            3: { 
                message: "Suas habilidades melhoram!",
                rewards: { hp: 15, atk: 2, def: 1, potions: 1 }
            },
            4: { 
                message: "Voc√™ se tornou um guerreiro experiente!",
                rewards: { hp: 20, atk: 2, def: 2, potions: 2 }
            },
            5: { 
                message: "Seu poder cresce rapidamente!",
                rewards: { hp: 25, atk: 3, def: 2, potions: 2 }
            },
            6: { 
                message: "Voc√™ √© um verdadeiro campe√£o!",
                rewards: { hp: 30, atk: 3, def: 3, potions: 2 }
            },
            7: { 
                message: "Sua lenda come√ßa a se formar!",
                rewards: { hp: 35, atk: 4, def: 3, potions: 3 }
            },
            8: { 
                message: "Seu nome √© conhecido por todos!",
                rewards: { hp: 40, atk: 4, def: 4, potions: 3 }
            },
            9: { 
                message: "Voc√™ est√° pr√≥ximo da maestria!",
                rewards: { hp: 50, atk: 5, def: 4, potions: 3 }
            },
            10: { 
                message: "üéâ VOC√ä ATINGIU O N√çVEL M√ÅXIMO! üéâ",
                rewards: { hp: 100, atk: 10, def: 10, potions: 5 },
                special: "MAX_LEVEL"
            }
        };

        const SKILLS = {
            // Habilidades desbloque√°veis por n√≠vel
            1: [],
            2: ['double_strike'], // Chance de ataque duplo
            3: ['counter_attack'], // Contra-ataque autom√°tico
            4: ['critical_boost'], // Aumento de cr√≠tico
            5: ['healing_boost'], // Melhora na cura
            6: ['loot_boost'], // Aumento de loot
            7: ['defense_stance'], // Postura defensiva
            8: ['berserker_rage'], // F√∫ria berserker
            9: ['ultimate_attack'], // Ataque supremo
            10: ['divine_blessing'] // B√™n√ß√£o divina
        };

        // ============================================
        // EQUIPMENT SYSTEM
        // ============================================
        const EQUIPMENT_SLOTS = {
            weapon: { name: 'Arma', icon: '‚öîÔ∏è', color: '#e74c3c' },
            shield: { name: 'Escudo', icon: 'üõ°Ô∏è', color: '#3498db' },
            helmet: { name: 'Capacete', icon: 'ü™ñ', color: '#95a5a6' },
            chest: { name: 'Tronco', icon: 'ü¶∫', color: '#2ecc71' },
            gloves: { name: 'Luvas', icon: 'üß§', color: '#f39c12' },
            boots: { name: 'Botas', icon: 'üë¢', color: '#8e44ad' }
        };

        const EQUIPMENT_ITEMS = {
            // Armas
            'espada_ferro': {
                name: 'Espada de Ferro',
                slot: 'weapon',
                rarity: 'common',
                stats: { atk: 3, def: 0 },
                value: 50,
                description: 'Uma espada b√°sica de ferro'
            },
            'espada_aco': {
                name: 'Espada de A√ßo',
                slot: 'weapon',
                rarity: 'uncommon',
                stats: { atk: 6, def: 1 },
                value: 120,
                description: 'Espada reforjada em a√ßo'
            },
            'espada_magica': {
                name: 'Espada M√°gica',
                slot: 'weapon',
                rarity: 'rare',
                stats: { atk: 10, def: 2 },
                value: 250,
                description: 'Espada encantada com poder arcano'
            },
            'machado_batalha': {
                name: 'Machado de Batalha',
                slot: 'weapon',
                rarity: 'uncommon',
                stats: { atk: 8, def: 0 },
                value: 150,
                description: 'Machado pesado para combate'
            },
            'martelo_guerra': {
                name: 'Martelo de Guerra',
                slot: 'weapon',
                rarity: 'rare',
                stats: { atk: 12, def: 1 },
                value: 300,
                description: 'Martelo devastador'
            },
            'espada_divina': {
                name: 'Espada Divina',
                slot: 'weapon',
                rarity: 'epic',
                stats: { atk: 18, def: 3 },
                value: 500,
                description: 'Forjada com poder celestial'
            },

            // Escudos
            'escudo_madeira': {
                name: 'Escudo de Madeira',
                slot: 'shield',
                rarity: 'common',
                stats: { atk: 0, def: 2 },
                value: 30,
                description: 'Escudo simples de madeira'
            },
            'escudo_ferro': {
                name: 'Escudo de Ferro',
                slot: 'shield',
                rarity: 'common',
                stats: { atk: 0, def: 4 },
                value: 60,
                description: 'Escudo b√°sico de ferro'
            },
            'escudo_aco': {
                name: 'Escudo de A√ßo',
                slot: 'shield',
                rarity: 'uncommon',
                stats: { atk: 0, def: 7 },
                value: 140,
                description: 'Escudo resistente de a√ßo'
            },
            'escudo_magico': {
                name: 'Escudo M√°gico',
                slot: 'shield',
                rarity: 'rare',
                stats: { atk: 1, def: 10 },
                value: 280,
                description: 'Escudo com prote√ß√£o arcanica'
            },
            'escudo_divino': {
                name: 'Escudo Divino',
                slot: 'shield',
                rarity: 'epic',
                stats: { atk: 2, def: 15 },
                value: 450,
                description: 'Escudo aben√ßoado pelos deuses'
            },

            // Capacetes
            'capacete_couro': {
                name: 'Capacete de Couro',
                slot: 'helmet',
                rarity: 'common',
                stats: { atk: 0, def: 1 },
                value: 25,
                description: 'Prote√ß√£o b√°sica para a cabe√ßa'
            },
            'capacete_ferro': {
                name: 'Capacete de Ferro',
                slot: 'helmet',
                rarity: 'common',
                stats: { atk: 0, def: 3 },
                value: 55,
                description: 'Capacete de ferro s√≥lido'
            },
            'capacete_aco': {
                name: 'Capacete de A√ßo',
                slot: 'helmet',
                rarity: 'uncommon',
                stats: { atk: 0, def: 5 },
                value: 130,
                description: 'Capacete refor√ßado de a√ßo'
            },
            'capacete_magico': {
                name: 'Capacete M√°gico',
                slot: 'helmet',
                rarity: 'rare',
                stats: { atk: 1, def: 7 },
                value: 260,
                description: 'Capacete com runas de prote√ß√£o'
            },
            'coroa_divina': {
                name: 'Coroa Divina',
                slot: 'helmet',
                rarity: 'epic',
                stats: { atk: 2, def: 12 },
                value: 400,
                description: 'Coroa com poder celestial'
            },

            // Troncos (Armaduras)
            'armadura_couro': {
                name: 'Armadura de Couro',
                slot: 'chest',
                rarity: 'common',
                stats: { atk: 0, def: 3 },
                value: 40,
                description: 'Armadura simples de couro'
            },
            'armadura_ferro': {
                name: 'Armadura de Ferro',
                slot: 'chest',
                rarity: 'common',
                stats: { atk: 0, def: 6 },
                value: 80,
                description: 'Armadura b√°sica de ferro'
            },
            'armadura_aco': {
                name: 'Armadura de A√ßo',
                slot: 'chest',
                rarity: 'uncommon',
                stats: { atk: 1, def: 10 },
                value: 180,
                description: 'Armadura completa de a√ßo'
            },
            'armadura_magica': {
                name: 'Armadura M√°gica',
                slot: 'chest',
                rarity: 'rare',
                stats: { atk: 2, def: 14 },
                value: 350,
                description: 'Armadura encantada'
            },
            'armadura_divina': {
                name: 'Armadura Divina',
                slot: 'chest',
                rarity: 'epic',
                stats: { atk: 3, def: 20 },
                value: 600,
                description: 'Armadura forjada celestialmente'
            },

            // Luvas
            'luvas_couro': {
                name: 'Luvas de Couro',
                slot: 'gloves',
                rarity: 'common',
                stats: { atk: 1, def: 1 },
                value: 20,
                description: 'Luvas simples de couro'
            },
            'luvas_ferro': {
                name: 'Luvas de Ferro',
                slot: 'gloves',
                rarity: 'common',
                stats: { atk: 2, def: 2 },
                value: 45,
                description: 'Luvas refor√ßadas de ferro'
            },
            'luvas_aco': {
                name: 'Luvas de A√ßo',
                slot: 'gloves',
                rarity: 'uncommon',
                stats: { atk: 3, def: 3 },
                value: 110,
                description: 'Luvas de a√ßo bem feitas'
            },
            'luvas_magicas': {
                name: 'Luvas M√°gicas',
                slot: 'gloves',
                rarity: 'rare',
                stats: { atk: 4, def: 4 },
                value: 220,
                description: 'Luvas com poder arcano'
            },
            'luvas_divinas': {
                name: 'Luvas Divinas',
                slot: 'gloves',
                rarity: 'epic',
                stats: { atk: 6, def: 6 },
                value: 380,
                description: 'Luvas aben√ßoadas'
            },

            // Botas
            'botas_couro': {
                name: 'Botas de Couro',
                slot: 'boots',
                rarity: 'common',
                stats: { atk: 0, def: 2 },
                value: 25,
                description: 'Botas simples de couro'
            },
            'botas_ferro': {
                name: 'Botas de Ferro',
                slot: 'boots',
                rarity: 'common',
                stats: { atk: 0, def: 4 },
                value: 50,
                description: 'Botas refor√ßadas de ferro'
            },
            'botas_aco': {
                name: 'Botas de A√ßo',
                slot: 'boots',
                rarity: 'uncommon',
                stats: { atk: 1, def: 6 },
                value: 120,
                description: 'Botas de a√ßo resistentes'
            },
            'botas_magicas': {
                name: 'Botas M√°gicas',
                slot: 'boots',
                rarity: 'rare',
                stats: { atk: 1, def: 8 },
                value: 240,
                description: 'Botas com velocidade m√°gica'
            },
            'botas_divinas': {
                name: 'Botas Divinas',
                slot: 'boots',
                rarity: 'epic',
                stats: { atk: 2, def: 12 },
                value: 420,
                description: 'Botas com poder celestial'
            }
        };

        const RARITY_COLORS = {
            common: '#95a5a6',
            uncommon: '#2ecc71',
            rare: '#3498db',
            epic: '#9b59b6',
            legendary: '#f1c40f'
        };

        // ============================================
        // SKILLS SYSTEM
        // ============================================
        const SKILLS_DATABASE = {
            // Habilidades Ofensivas
            'double_strike': {
                name: 'Golpe Duplo',
                icon: '‚öîÔ∏è',
                description: 'Ataca duas vezes com 70% do dano',
                type: 'offensive',
                element: 'physical',
                cooldown: 3,
                effect: 'attack_twice',
                rarity: 'common',
                statusEffect: null
            },
            'fire_strike': {
                name: 'Golpe de Fogo',
                icon: 'üî•',
                description: 'Ataque elemental de fogo com chance de queimar',
                type: 'offensive',
                element: 'fire',
                cooldown: 3,
                effect: 'elemental_damage',
                rarity: 'common',
                statusEffect: { type: 'burn', chance: 0.3 }
            },
            'ice_shard': {
                name: 'Estilha√ßo de Gelo',
                icon: '‚ùÑÔ∏è',
                description: 'Ataque de gelo com chance de congelar',
                type: 'offensive',
                element: 'water',
                cooldown: 3,
                effect: 'elemental_damage',
                rarity: 'uncommon',
                statusEffect: { type: 'freeze', chance: 0.25 }
            },
            'lightning_bolt': {
                name: 'Raio',
                icon: '‚ö°',
                description: 'Ataque el√©trico com chance de atordoar',
                type: 'offensive',
                element: 'lightning',
                cooldown: 4,
                effect: 'elemental_damage',
                rarity: 'rare',
                statusEffect: { type: 'stun', chance: 0.2 }
            },
            'berserker_rage': {
                name: 'F√∫ria Berserker',
                icon: 'üî•',
                description: '+50% ATK mas -10 DEF por 3 turnos',
                type: 'offensive',
                element: 'fire',
                cooldown: 4,
                effect: 'berserk_mode',
                rarity: 'rare',
                statusEffect: { type: 'rage', chance: 1.0, target: 'self' }
            },
            'ultimate_attack': {
                name: 'Ataque Supremo',
                icon: '‚ö°',
                description: 'Dano massivo com 200% de ATK',
                type: 'offensive',
                element: 'lightning',
                cooldown: 5,
                effect: 'ultimate_damage',
                rarity: 'epic',
                statusEffect: null
            },
            'poison_blade': {
                name: 'Lamina Venenosa',
                icon: 'üêç',
                description: 'Envenena o inimigo (dano por turno)',
                type: 'offensive',
                element: 'nature',
                cooldown: 3,
                effect: 'poison_damage',
                rarity: 'uncommon',
                statusEffect: { type: 'poison', chance: 0.4 }
            },
            'holy_strike': {
                name: 'Golpe Sagrado',
                icon: '‚ú®',
                description: 'Ataque de luz eficaz contra sombra',
                type: 'offensive',
                element: 'light',
                cooldown: 4,
                effect: 'elemental_damage',
                rarity: 'rare',
                statusEffect: { type: 'weak', chance: 0.3 }
            },
            'shadow_bolt': {
                name: 'Proj√©til Sombrio',
                icon: 'üåë',
                description: 'Ataque de sombra que causa sangramento',
                type: 'offensive',
                element: 'dark',
                cooldown: 4,
                effect: 'elemental_damage',
                rarity: 'rare',
                statusEffect: { type: 'bleed', chance: 0.35 }
            },
            'earthquake': {
                name: 'Terremoto',
                icon: 'ü™®',
                description: 'Dano em √°rea com chance de atordoar',
                type: 'offensive',
                element: 'earth',
                cooldown: 5,
                effect: 'area_damage',
                rarity: 'epic',
                statusEffect: { type: 'stun', chance: 0.4 }
            },

            // Habilidades Defensivas
            'counter_attack': {
                name: 'Contra-Ataque',
                icon: 'üõ°Ô∏è',
                description: 'Reflete 50% do dano recebido',
                type: 'defensive',
                element: 'physical',
                cooldown: 2,
                effect: 'damage_reflect',
                rarity: 'common',
                statusEffect: null
            },
            'defense_stance': {
                name: 'Postura Defensiva',
                icon: 'üõ°Ô∏è',
                description: '+50% DEF por 2 turnos',
                type: 'defensive',
                element: 'earth',
                cooldown: 3,
                effect: 'defense_boost',
                rarity: 'uncommon',
                statusEffect: { type: 'shield', chance: 1.0, target: 'self' }
            },
            'divine_shield': {
                name: 'Escudo Divino',
                icon: '‚ú®',
                description: 'Bloqueia 100% do dano por 1 turno',
                type: 'defensive',
                element: 'light',
                cooldown: 4,
                effect: 'damage_immunity',
                rarity: 'epic',
                statusEffect: { type: 'shield', chance: 1.0, target: 'self', duration: 1 }
            },

            // Habilidades de Suporte
            'healing_boost': {
                name: 'Cura Aprimorada',
                icon: 'üíö',
                description: '+50% de efic√°cia em po√ß√µes',
                type: 'support',
                element: 'nature',
                cooldown: 1,
                effect: 'heal_boost',
                rarity: 'common',
                statusEffect: null
            },
            'regeneration': {
                name: 'Regenera√ß√£o',
                icon: 'üíö',
                description: 'Cura cont√≠nua por 3 turnos',
                type: 'support',
                element: 'nature',
                cooldown: 4,
                effect: 'heal_over_time',
                rarity: 'uncommon',
                statusEffect: { type: 'regen', chance: 1.0, target: 'self' }
            },
            'focus_mind': {
                name: 'Foco Mental',
                icon: 'üéØ',
                description: '+100% chance de cr√≠tico por 2 turnos',
                type: 'support',
                element: 'psychic',
                cooldown: 3,
                effect: 'critical_boost',
                rarity: 'rare',
                statusEffect: { type: 'focus', chance: 1.0, target: 'self' }
            },
            'loot_boost': {
                name: 'Sorte do Ca√ßador',
                icon: 'üçÄ',
                description: '+30% de chance de loot raro',
                type: 'support',
                element: 'psychic',
                cooldown: 5,
                effect: 'luck_boost',
                rarity: 'rare',
                statusEffect: null
            }
        };

        const SKILL_TYPES = {
            offensive: { name: 'Ofensiva', color: '#e74c3c' },
            defensive: { name: 'Defensiva', color: '#3498db' },
            support: { name: 'Suporte', color: '#2ecc71' }
        };

        const SKILL_RARITY_COLORS = {
            common: '#95a5a6',
            uncommon: '#2ecc71',
            rare: '#3498db',
            epic: '#9b59b6'
        };

        // ============================================
        // ELEMENTAL SYSTEM
        // ============================================
        const ELEMENTS = {
            fire: { name: 'Fogo', icon: 'üî•', color: '#e74c3c', weak: 'water', strong: 'nature' },
            water: { name: '√Ågua', icon: 'üíß', color: '#3498db', weak: 'nature', strong: 'fire' },
            nature: { name: 'Natureza', icon: 'üåø', color: '#2ecc71', weak: 'fire', strong: 'water' },
            lightning: { name: 'Rel√¢mpago', icon: '‚ö°', color: '#f1c40f', weak: 'earth', strong: 'air' },
            earth: { name: 'Terra', icon: 'ü™®', color: '#95a5a6', weak: 'air', strong: 'lightning' },
            air: { name: 'Ar', icon: 'üí®', color: '#ecf0f1', weak: 'lightning', strong: 'earth' },
            dark: { name: 'Sombra', icon: 'üåë', color: '#2c3e50', weak: 'light', strong: 'psychic' },
            light: { name: 'Luz', icon: '‚ú®', color: '#f1c40f', weak: 'psychic', strong: 'dark' },
            psychic: { name: 'Ps√≠quico', icon: 'üîÆ', color: '#9b59b6', weak: 'dark', strong: 'light' },
            physical: { name: 'F√≠sico', icon: '‚öîÔ∏è', color: '#7f8c8d', weak: null, strong: null }
        };

        // ============================================
        // STATUS EFFECTS SYSTEM
        // ============================================
        const STATUS_EFFECTS = {
            burn: {
                name: 'Queimadura',
                icon: 'üî•',
                color: '#e74c3c',
                description: 'Dano cont√≠nuo por turno',
                damage: true,
                duration: 3,
                effect: 'damage_per_turn'
            },
            poison: {
                name: 'Veneno',
                icon: '‚ò†Ô∏è',
                color: '#8e44ad',
                description: 'Dano cont√≠nuo por turno',
                damage: true,
                duration: 4,
                effect: 'damage_per_turn'
            },
            freeze: {
                name: 'Congelado',
                icon: '‚ùÑÔ∏è',
                color: '#3498db',
                description: 'N√£o pode atacar',
                disable: true,
                duration: 2,
                effect: 'disable_attack'
            },
            stun: {
                name: 'Atordoado',
                icon: 'üí´',
                color: '#f1c40f',
                description: 'N√£o pode agir',
                disable: true,
                duration: 1,
                effect: 'disable_all'
            },
            bleed: {
                name: 'Sangramento',
                icon: 'ü©∏',
                color: '#c0392b',
                description: 'Dano cont√≠nuo por turno',
                damage: true,
                duration: 5,
                effect: 'damage_per_turn'
            },
            regen: {
                name: 'Regenera√ß√£o',
                icon: 'üíö',
                color: '#2ecc71',
                description: 'Cura cont√≠nua por turno',
                heal: true,
                duration: 3,
                effect: 'heal_per_turn'
            },
            shield: {
                name: 'Escudo',
                icon: 'üõ°Ô∏è',
                color: '#3498db',
                description: 'Reduz dano recebido',
                buff: true,
                duration: 3,
                effect: 'damage_reduction'
            },
            rage: {
                name: 'F√∫ria',
                icon: 'üò°',
                color: '#e74c3c',
                description: '+50% ATK, -20% DEF',
                buff: true,
                duration: 4,
                effect: 'atk_boost_def_reduction'
            },
            focus: {
                name: 'Foco',
                icon: 'üéØ',
                color: '#f1c40f',
                description: '+100% chance de cr√≠tico',
                buff: true,
                duration: 2,
                effect: 'critical_boost'
            },
            weak: {
                name: 'Enfraquecido',
                icon: 'üíî',
                color: '#95a5a6',
                description: '-30% ATK e DEF',
                debuff: true,
                duration: 3,
                effect: 'stats_reduction'
            }
        };

        
        // ============================================
        // UTILITIES
        // ============================================
        const Utils = {
            // Formata√ß√£o de n√∫meros
            formatNumber(num) {
                return num.toLocaleString('pt-BR');
            },

            // Gera√ß√£o de ID √∫nico
            generateId() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            },

            // Deep clone
            deepClone(obj) {
                return JSON.parse(JSON.stringify(obj));
            },

            // Debounce para performance
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            // Throttle para performance
            throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            // Valida√ß√£o de estado
            validateState(state) {
                const required = ['hero', 'screen', 'gold'];
                return required.every(key => state.hasOwnProperty(key));
            },

            // C√°lculo de chance
            chance(percentage) {
                return Math.random() < percentage;
            },

            // Range aleat√≥rio
            randomBetween(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },

            // Sele√ß√£o ponderada
            weightedRandom(items, weights) {
                const totalWeight = weights.reduce((a, b) => a + b, 0);
                let random = Math.random() * totalWeight;
                
                for (let i = 0; i < items.length; i++) {
                    random -= weights[i];
                    if (random <= 0) {
                        return items[i];
                    }
                }
                return items[items.length - 1];
            }
        };

        // ============================================
        // ERROR HANDLING
        // ============================================
        class GameError extends Error {
            constructor(message, code = 'GAME_ERROR') {
                super(message);
                this.name = 'GameError';
                this.code = code;
            }
        }

        const ErrorHandler = {
            handle(error, context = 'Unknown') {
                console.error(`[${context}] ${error.name}: ${error.message}`, error);
                
                // Mostrar mensagem amig√°vel ao usu√°rio
                if (typeof game !== 'undefined' && game.addLog) {
                    game.addLog(`‚ùå Erro: ${error.message}`);
                }
                
                // Salvar erro para debugging
                this.logError(error, context);
            },

            logError(error, context) {
                const errorLog = {
                    timestamp: new Date().toISOString(),
                    context,
                    message: error.message,
                    stack: error.stack,
                    state: game?.state ? Utils.deepClone(game.state) : null
                };
                
                // Salvar em localStorage (√∫ltimos 10 erros)
                const errors = JSON.parse(localStorage.getItem('game_errors') || '[]');
                errors.push(errorLog);
                if (errors.length > 10) errors.shift();
                localStorage.setItem('game_errors', JSON.stringify(errors));
            },

            wrap(func, context) {
                return (...args) => {
                    try {
                        return func.apply(this, args);
                    } catch (error) {
                        this.handle(error, context);
                        return null;
                    }
                };
            }
        };

        // ============================================
        // PERFORMANCE MONITOR
        // ============================================
        class PerformanceMonitor {
            constructor() {
                this.metrics = {
                    renders: 0,
                    renderTime: 0,
                    lastRender: 0,
                    fps: 0
                };
                this.startTime = performance.now();
            }

            startRender() {
                this.metrics.lastRender = performance.now();
            }

            endRender() {
                const renderTime = performance.now() - this.metrics.lastRender;
                this.metrics.renders++;
                this.metrics.renderTime += renderTime;
                
                // Calcular FPS
                const totalTime = performance.now() - this.startTime;
                this.metrics.fps = Math.round((this.metrics.renders / totalTime) * 1000);
                
                // Log se render estiver lento
                if (renderTime > 16) { // > 60fps
                    console.warn(`Slow render: ${renderTime.toFixed(2)}ms`);
                }
            }

            getMetrics() {
                return {
                    ...this.metrics,
                    avgRenderTime: this.metrics.renderTime / this.metrics.renders
                };
            }
        }

        // ============================================
        // PARTICLE SYSTEM
        // ============================================
        class ParticleSystem {
            constructor() {
                this.container = document.getElementById('app');
            }

            createDamageNumber(x, y, damage, isCritical = false) {
                const particle = document.createElement('div');
                particle.className = `damage-number ${isCritical ? 'critical' : 'normal'}`;
                particle.textContent = `-${damage}`;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                this.container.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1500);
            }

            createHealNumber(x, y, heal) {
                const particle = document.createElement('div');
                particle.className = 'heal-number';
                particle.textContent = `+${heal}`;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                this.container.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1500);
            }

            createEffect(type, element) {
                const rect = element.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top + rect.height / 2;

                switch(type) {
                    case 'attack':
                        this.createAttackEffect(x, y);
                        break;
                    case 'damage':
                        this.createDamageEffect(x, y);
                        break;
                    case 'heal':
                        this.createHealEffect(x, y);
                        break;
                }
            }

            createAttackEffect(x, y) {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const spark = document.createElement('div');
                        spark.style.position = 'fixed';
                        spark.style.left = `${x + (Math.random() - 0.5) * 40}px`;
                        spark.style.top = `${y + (Math.random() - 0.5) * 40}px`;
                        spark.style.width = '4px';
                        spark.style.height = '4px';
                        spark.style.background = '#ffd93d';
                        spark.style.borderRadius = '50%';
                        spark.style.pointerEvents = 'none';
                        spark.style.zIndex = '999';
                        spark.style.animation = 'floatUp 0.8s ease-out forwards';
                        
                        document.body.appendChild(spark);
                        setTimeout(() => spark.remove(), 800);
                    }, i * 50);
                }
            }

            createDamageEffect(x, y) {
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'fixed';
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    particle.style.width = '6px';
                    particle.style.height = '6px';
                    particle.style.background = '#ff6b6b';
                    particle.style.borderRadius = '50%';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '999';
                    
                    const angle = (Math.PI * 2 * i) / 8;
                    const distance = 50 + Math.random() * 30;
                    
                    particle.animate([
                        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                        { 
                            transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px) scale(0)`,
                            opacity: 0 
                        }
                    ], {
                        duration: 600,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    });
                    
                    document.body.appendChild(particle);
                    setTimeout(() => particle.remove(), 600);
                }
            }

            createHealEffect(x, y) {
                for (let i = 0; i < 6; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'fixed';
                    particle.style.left = `${x + (Math.random() - 0.5) * 30}px`;
                    particle.style.top = `${y + (Math.random() - 0.5) * 30}px`;
                    particle.style.width = '8px';
                    particle.style.height = '8px';
                    particle.style.background = '#2ecc71';
                    particle.style.borderRadius = '50%';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '999';
                    particle.style.boxShadow = '0 0 10px #2ecc71';
                    
                    particle.animate([
                        { transform: 'translateY(0) scale(0)', opacity: 0 },
                        { transform: 'translateY(-20px) scale(1)', opacity: 1 },
                        { transform: 'translateY(-40px) scale(0)', opacity: 0 }
                    ], {
                        duration: 1000,
                        easing: 'ease-out'
                    });
                    
                    document.body.appendChild(particle);
                    setTimeout(() => particle.remove(), 1000);
                }
            }
        }

        // ============================================
        // STATE MANAGER
        // ============================================
        class StateManager {
            constructor() {
                this.history = [];
                this.maxHistory = 10;
            }

            saveState(state) {
                this.history.push(JSON.stringify(state));
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
            }

            undo() {
                if (this.history.length > 1) {
                    this.history.pop(); // Remove estado atual
                    return JSON.parse(this.history[this.history.length - 1]);
                }
                return null;
            }

            clear() {
                this.history = [];
            }
        }

        // ============================================
        // DOM CACHE MANAGER
        // ============================================
        class DOMCache {
            constructor() {
                this.cache = new Map();
            }

            get(selector) {
                if (!this.cache.has(selector)) {
                    const element = document.querySelector(selector);
                    if (element) {
                        this.cache.set(selector, element);
                    }
                }
                return this.cache.get(selector);
            }

            clear() {
                this.cache.clear();
            }

            invalidate(selector) {
                this.cache.delete(selector);
            }
        }

        // ============================================
        // GAME CLASS
        // ============================================
        class Game {
            constructor() {
                // Cache para memoiza√ß√£o
                this.renderCache = new Map();
                this.lastRenderState = null;
                
                // Performance e error handling
                this.performanceMonitor = new PerformanceMonitor();
                this.errorHandler = ErrorHandler;
                
                this.state = {
                    screen: 'home',
                    hero: { ...INITIAL_HERO },
                    floor: 1,
                    gold: INITIAL_HERO.gold,
                    enemy: null,
                    logs: [],
                    isPlayerTurn: true,
                    isAutoBattle: false,
                    gameId: null,
                    availableClasses: [],
                    inventory: [],
                    materials: {},
                    equipment: { 
                        weapon: null, 
                        armor: null, 
                        accessory: null
                    },
                    buffs: [],
                    skills: [],
                    unlockedSkills: [],
                    equippedSkills: [null, null, null, null, null],
                    skillCooldowns: {},
                    statusEffects: { hero: [], enemy: [] },
                    luckBoost: 1,
                    campLevel: 1,
                    merchant: null,
                    merchantVisit: 0,
                    currentPaths: [],
                    pathSelection: false,
                    selectedPath: null
                };
                
                // Lazy loading de sistemas pesados
                this._particleSystem = null;
                this._stateManager = null;
                this._audioManager = null;
                
                this.settings = {
                    animationSpeed: 1,
                    soundVolume: 0.5,
                    autoSaveInterval: 30000
                };
                this.isAutoBattleRunning = false;
                this.autoBattleInterval = null;
                
                // Carregar configura√ß√µes
                this.loadSettings();
                
                this.loadGame();
                this.render();
                
                // Auto-save
                setInterval(() => {
                    this.saveGame();
                }, this.settings.autoSaveInterval);
            }

            // Lazy getters para sistemas pesados
            get particleSystem() {
                if (!this._particleSystem) {
                    this._particleSystem = new ParticleSystem();
                }
                return this._particleSystem;
            }

            get stateManager() {
                if (!this._stateManager) {
                    this._stateManager = new StateManager();
                }
                return this._stateManager;
            }

            get audioManager() {
                if (!this._audioManager) {
                    this._audioManager = new AudioManager();
                }
                return this._audioManager;
            }

            // ========== STATE MANAGEMENT ==========
            setState(newState) {
                this.state = { ...this.state, ...newState };
                // Invalidar cache quando estado muda
                this.renderCache.clear();
                this.lastRenderState = null;
                this.render();
            }

            saveGame() {
                const saveData = {
                    hero: this.state.hero,
                    floor: this.state.floor,
                    gold: this.state.gold,
                    gameId: this.state.gameId || Date.now(),
                    inventory: this.state.inventory,
                    equipment: this.state.equipment,
                    materials: this.state.materials,
                    availableClasses: this.state.availableClasses
                };
                localStorage.setItem('pixelquest_save', JSON.stringify(saveData));
            }

            loadGame() {
                const saved = localStorage.getItem('pixelquest_save');
                if (saved) {
                    const data = JSON.parse(saved);
                    this.state.hero = data.hero || { ...INITIAL_HERO };
                    this.state.floor = data.floor || 1;
                    this.state.gold = data.gold || INITIAL_HERO.gold;
                    this.state.gameId = data.gameId;
                    this.state.inventory = data.inventory || [];
                    this.state.equipment = data.equipment || { weapon: null, armor: null, accessory: null };
                    this.state.materials = data.materials || {};
                    this.state.availableClasses = data.availableClasses || [];
                }
            }

            resetGame() {
                if (confirm('Tem certeza que quer resetar todo o progresso?')) {
                    localStorage.removeItem('pixelquest_save');
                    this.state = {
                        screen: 'home',
                        hero: { ...INITIAL_HERO },
                        floor: 1,
                        gold: INITIAL_HERO.gold,
                        enemy: null,
                        logs: [],
                        isPlayerTurn: true,
                        isAutoBattle: false,
                        gameId: null,
                        availableClasses: [],
                        inventory: [],
                        equipment: {
                            weapon: null,
                            armor: null,
                            accessory: null
                        },
                        materials: {},
                        skillCooldowns: {},
                        luckBoost: 1
                    };
                    this.render();
                }
            }

            // ========== LOGGING ==========
            addLog(message) {
                this.state.logs = [message, ...this.state.logs].slice(0, 5);
                this.render();
            }

            // ========== LOOT SYSTEM ==========
            rollLootTier(isBoss = false) {
                const roll = Math.random();
                let chance = roll;
                
                // Aumentar chance para chefes
                if (isBoss) {
                    chance = Math.min(1, roll + 0.3);
                }
                
                // Aplicar boost de sorte
                chance = Math.min(1, chance + (this.state.luckBoost - 1) * 0.2);
                
                for (const [tier, data] of Object.entries(LOOT_TIERS)) {
                    if (chance < data.chance) {
                        return { tier, ...data };
                    }
                    chance -= data.chance;
                }
                
                return { tier: 'common', ...LOOT_TIERS.common };
            }

            generateLoot(enemy, isBoss = false) {
                const loot = [];
                const lootTier = this.rollLootTier(isBoss);
                
                // Ouro base
                const goldAmount = Math.floor(enemy.gold * lootTier.multiplier);
                loot.push({
                    type: 'gold',
                    amount: goldAmount,
                    rarity: lootTier.tier,
                    icon: 'ü™ô',
                    name: `${goldAmount} Ouro`
                });
                
                // Chance de moeda prata
                if (Math.random() < 0.3) {
                    const silverAmount = Math.floor(goldAmount * 0.2);
                    loot.push({
                        type: 'silver',
                        amount: silverAmount,
                        rarity: 'common',
                        icon: 'ü•à',
                        name: `${silverAmount} Prata`
                    });
                }
                
                // Materiais espec√≠ficos do inimigo
                const material = this.getEnemyMaterial(enemy);
                if (material && Math.random() < (isBoss ? 0.8 : 0.4)) {
                    const materialCount = isBoss ? Math.floor(Math.random() * 3) + 2 : 1;
                    loot.push({
                        type: 'material',
                        id: material.id,
                        amount: materialCount,
                        rarity: material.rarity,
                        icon: material.icon,
                        name: `${material.name} x${materialCount}`
                    });
                }
                
                // Chance de gema
                if (Math.random() < (isBoss ? 0.6 : 0.1)) {
                    loot.push({
                        type: 'gem',
                        amount: 1,
                        rarity: lootTier.tier,
                        icon: 'üíé',
                        name: `Gema ${lootTier.name}`
                    });
                }
                
                // Equipamento (chance maior para chefes)
                if (Math.random() < (isBoss ? 0.4 : 0.05)) {
                    const equipment = this.generateEquipment(enemy.level, lootTier.tier);
                    if (equipment) {
                        loot.push({
                            type: 'equipment',
                            ...equipment,
                            rarity: equipment.rarity
                        });
                    }
                }
                
                // Ba√∫ aleat√≥rio (chance pequena)
                if (Math.random() < 0.05) {
                    loot.push({
                        type: 'chest',
                        rarity: 'rare',
                        icon: 'üì¶',
                        name: 'Ba√∫ Misterioso'
                    });
                }
                
                return loot;
            }

            getEnemyMaterial(enemy) {
                const materialMap = {
                    'Slime': 'slime_goo',
                    'Bat': 'bat_wing',
                    'Goblin': 'goblin_ear',
                    'Skeleton': 'skeleton_bone',
                    'Orc': 'orc_tusk',
                    'Dark Knight': 'dark_essence',
                    'Demon Lord': 'demon_horn',
                    'Ancient Dragon': 'dragon_scale',
                    'Lich King': 'lich_phylactery'
                };
                
                const materialId = materialMap[enemy.name];
                return MATERIALS.find(m => m.id === materialId);
            }

            generateEquipment(level, rarity) {
                const equipmentByRarity = EQUIPMENT.filter(eq => eq.rarity === rarity);
                if (equipmentByRarity.length === 0) return null;
                
                return equipmentByRarity[Math.floor(Math.random() * equipmentByRarity.length)];
            }

            collectLoot(loot) {
                const messages = [];
                
                loot.forEach(item => {
                    switch(item.type) {
                        case 'gold':
                            this.setState({ gold: this.state.gold + item.amount });
                            messages.push(`+${item.amount} Ouro`);
                            break;
                        case 'silver':
                            this.setState({ gold: this.state.gold + Math.floor(item.amount * 0.5) });
                            messages.push(`+${item.amount} Prata`);
                            break;
                        case 'material':
                            this.addMaterial(item.id, item.amount);
                            messages.push(`+${item.name}`);
                            break;
                        case 'gem':
                            this.addToInventory(item);
                            messages.push(`+${item.name}`);
                            break;
                        case 'equipment':
                            this.addToInventory(item);
                            messages.push(`+${item.name} (${item.rarity})`);
                            
                            // Oferecer op√ß√£o de equipar automaticamente se for melhor
                            this.offerToEquip(item);
                            break;
                        case 'chest':
                            this.openChest();
                            messages.push(`+${item.name}`);
                            break;
                    }
                });
                
                return messages;
            }

            offerToEquip(item) {
                // Verificar se o item √© equip√°vel
                if (!['weapon', 'armor', 'accessory'].includes(item.type)) return;
                
                const { equipment } = this.state;
                const currentItem = equipment[item.type];
                const equipmentStats = this.getEquipmentStats();
                
                // Calcular stats atuais vs novos
                const currentAtk = equipmentStats.atk;
                const currentDef = equipmentStats.def;
                
                // Simular stats com novo item
                let newAtk = currentAtk;
                let newDef = currentDef;
                
                if (currentItem) {
                    if (currentItem.type === 'weapon') newAtk -= currentItem.stats.atk || 0;
                    if (currentItem.type === 'armor') newDef -= currentItem.stats.def || 0;
                    if (currentItem.type === 'accessory') {
                        newAtk -= currentItem.stats.atk || 0;
                        newDef -= currentItem.stats.def || 0;
                    }
                }
                
                if (item.type === 'weapon') newAtk += item.stats.atk || 0;
                if (item.type === 'armor') newDef += item.stats.def || 0;
                if (item.type === 'accessory') {
                    newAtk += item.stats.atk || 0;
                    newDef += item.stats.def || 0;
                }
                
                // Se o novo item for melhor, oferecer para equipar
                const isBetter = (item.type === 'weapon' && newAtk > currentAtk) ||
                                (item.type === 'armor' && newDef > currentDef) ||
                                (item.type === 'accessory' && (newAtk > currentAtk || newDef > currentDef));
                
                if (isBetter) {
                    setTimeout(() => {
                        this.addLog(`üí° ${item.name} √© melhor que seu equipamento atual!`);
                        this.addLog(`üìä Use üéí ITENS para equipar manualmente.`);
                    }, 1000);
                }
            }

            addMaterial(materialId, amount) {
                const materials = { ...this.state.materials };
                materials[materialId] = (materials[materialId] || 0) + amount;
                this.setState({ materials });
            }

            addToInventory(item) {
                const inventory = [...this.state.inventory, item];
                this.setState({ inventory });
            }

            openChest() {
                const chestLoot = [];
                const goldAmount = Math.floor(Math.random() * 200) + 100;
                chestLoot.push({
                    type: 'gold',
                    amount: goldAmount,
                    rarity: 'rare',
                    icon: 'ü™ô',
                    name: `${goldAmount} Ouro`
                });
                
                // Chance de item raro no ba√∫
                if (Math.random() < 0.7) {
                    const equipment = this.generateEquipment(this.state.floor, 'rare');
                    if (equipment) {
                        chestLoot.push({
                            type: 'equipment',
                            ...equipment,
                            rarity: 'rare'
                        });
                    }
                }
                
                // Chance de armadilha
                if (Math.random() < 0.2) {
                    const damage = Math.floor(this.state.hero.maxHp * 0.2);
                    this.setState({
                        hero: { ...this.state.hero, hp: Math.max(1, this.state.hero.hp - damage) }
                    });
                    this.addLog(`üí• Armadilha! Perdeu ${damage} HP mas encontrou tesouros!`);
                } else {
                    this.addLog(`üì¶ Ba√∫ aberto com sucesso!`);
                }
                
                this.collectLoot(chestLoot);
            }

            // ========== SETTINGS ==========
            loadSettings() {
                const saved = localStorage.getItem('pixelquest_settings');
                if (saved) {
                    this.settings = { ...this.settings, ...JSON.parse(saved) };
                }
            }

            saveSettings() {
                localStorage.setItem('pixelquest_settings', JSON.stringify(this.settings));
            }

            updateSettings(newSettings) {
                this.settings = { ...this.settings, ...newSettings };
                this.saveSettings();
            }

            // ========== NAVIGATION ==========
            showScreen(screen) {
                // Resetar auto-battle quando sair da batalha
                if (screen !== 'battle') {
                    this.isAutoBattleRunning = false;
                }
                this.setState({ screen });
            }

            // Sistema de Classes
            getClassStats(className, level = 1) {
                const classData = CLASS_SYSTEM[className];
                if (!classData) return { hp: 100, atk: 10, def: 5 };
                
                const stats = { ...classData.baseStats };
                
                // Aplicar crescimento por n√≠vel
                for (let i = 1; i < level; i++) {
                    stats.hp += classData.growthRates.hp;
                    stats.atk += classData.growthRates.atk;
                    stats.def += classData.growthRates.def;
                }
                
                return stats;
            }

            getAvailableClasses(currentClass, level, hasDefeatedFirstBoss = false) {
                const available = [];
                
                if (currentClass === "aprendiz" && hasDefeatedFirstBoss) {
                    // Primeira escolha (ap√≥s primeiro chefe)
                    available.push("guerreiro", "mago", "ladrao");
                } else if (level >= 20) {
                    // Segunda escolha (n√≠vel 20)
                    if (currentClass === "guerreiro") {
                        available.push("paladino", "cavaleiro");
                    } else if (currentClass === "mago") {
                        available.push("arcanista", "necromante");
                    } else if (currentClass === "ladrao") {
                        available.push("assassino", "ninja");
                    }
                } else if (level >= 40) {
                    // Terceira escolha (n√≠vel 40)
                    if (currentClass === "paladino") {
                        available.push("cavaleiro_sagrado");
                    } else if (currentClass === "cavaleiro") {
                        available.push("mestre_guerra");
                    } else if (currentClass === "arcanista") {
                        available.push("arqui_mago");
                    } else if (currentClass === "necromante") {
                        available.push("lorde_das_trevas");
                    } else if (currentClass === "assassino") {
                        available.push("mestre_assassino");
                    } else if (currentClass === "ninja") {
                        available.push("mestre_ninja");
                    }
                }
                
                return available;
            }

            changeClass(newClassName) {
                const { hero } = this.state;
                const newClass = CLASS_SYSTEM[newClassName];
                
                if (!newClass) return;
                
                // Calcular stats baseados no n√≠vel atual
                const newStats = this.getClassStats(newClassName, hero.level);
                
                // Preservar HP percentual
                const hpPercent = hero.hp / hero.maxHp;
                
                // Atualizar her√≥i com nova classe
                const updatedHero = {
                    ...hero,
                    class: newClassName,
                    classHistory: [...hero.classHistory, newClassName],
                    hp: Math.floor(newStats.hp * hpPercent),
                    maxHp: newStats.hp,
                    atk: newStats.atk,
                    def: newStats.def,
                    skills: [...newClass.skills]
                };
                
                this.setState({ hero: updatedHero });
                this.addLog(`üé≠ Classe alterada para ${newClass.icon} ${newClass.name}!`);
            }

            checkForClassEvolution() {
                const { hero } = this.state;
                const availableClasses = this.getAvailableClasses(hero.class, hero.level, hero.hasDefeatedFirstBoss);
                
                if (availableClasses.length > 0) {
                    this.setState({
                        availableClasses: availableClasses,
                        screen: 'classSelection'
                    });
                    return true;
                }
                
                return false;
            }

            applyClassStats() {
                const { hero } = this.state;
                const classStats = this.getClassStats(hero.class, hero.level);
                
                // Atualizar stats base da classe
                const updatedHero = {
                    ...hero,
                    maxHp: classStats.hp,
                    atk: classStats.atk,
                    def: classStats.def
                };
                
                this.setState({ hero: updatedHero });
            }

            // ========== GAME ACTIONS ==========

            // ========== DEBUG SYSTEM ==========
            debugSystem() {
                const { hero } = this.state;
                console.log('=== DEBUG DO SISTEMA ===');
                console.log('Her√≥i:', hero);
                console.log('Classe:', hero.class);
                console.log('N√≠vel:', hero.level);
                console.log('Primeiro Chefe Derrotado:', hero.hasDefeatedFirstBoss);
                console.log('Classes Dispon√≠veis:', this.getAvailableClasses(hero.class, hero.level, hero.hasDefeatedFirstBoss));
                console.log('Stats da Classe:', this.getClassStats(hero.class, hero.level));
                console.log('Stats Totais:', this.getTotalStats());
                console.log('Equipamentos:', this.state.equipment);
                console.log('Invent√°rio:', this.state.inventory);
                console.log('========================');
            }

            startGame(name) {
                if (!name.trim()) return;
                const hero = { ...INITIAL_HERO, name: name.trim() };
                this.setState({ 
                    hero, 
                    screen: 'menu',
                    gameId: Date.now(),
                    logs: [`Bem-vindo, ${hero.name}!`]
                });
            }

            startBattle() {
                const { floor, hero } = this.state;
                let enemy;
                let logMessage;

                // Verificar se √© fase de chefe (a cada 10 n√≠veis)
                if (floor % 10 === 0) {
                    const bossIndex = Math.floor((floor - 10) / 10) % BOSSES.length;
                    const baseBoss = BOSSES[bossIndex];
                    const scale = 1 + ((floor - 10) * 0.05);
                    
                    enemy = {
                        ...baseBoss,
                        hp: Math.floor(baseBoss.hp * scale),
                        maxHp: Math.floor(baseBoss.maxHp * scale),
                        atk: Math.floor(baseBoss.atk * scale),
                        gold: Math.floor(baseBoss.gold * scale),
                        exp: Math.floor(baseBoss.exp * scale),
                        isBoss: true
                    };
                    
                    logMessage = `‚ö†Ô∏è CHEFE APARECEU: ${enemy.name}!`;
                } else {
                    // Calcular quantidade de inimigos (1-6 conforme progress√£o)
                    const enemyCount = Math.min(6, 1 + Math.floor((floor - 1) / 3));
                    const enemyIndex = Math.min(Math.floor((floor - 1) / 2), ENEMIES.length - 1);
                    const baseEnemy = ENEMIES[enemyIndex];
                    const scale = 1 + (floor * 0.1);
                    
                    // Para m√∫ltiplos inimigos, vamos criar um inimigo "grupo"
                    if (enemyCount > 1) {
                        const totalHp = Math.floor(baseEnemy.hp * scale * enemyCount * 0.8);
                        const totalAtk = Math.floor(baseEnemy.atk * scale * (1 + enemyCount * 0.2));
                        const totalExp = Math.floor(baseEnemy.exp * scale * enemyCount);
                        const totalGold = Math.floor(baseEnemy.gold * scale * enemyCount);
                        
                        enemy = {
                            name: `${baseEnemy.name} x${enemyCount}`,
                            hp: totalHp,
                            maxHp: totalHp,
                            atk: totalAtk,
                            exp: totalExp,
                            gold: totalGold,
                            sprite: baseEnemy.sprite,
                            isBoss: false,
                            enemyCount: enemyCount
                        };
                        
                        logMessage = `Encontrou ${enemyCount} ${baseEnemy.name}s!`;
                    } else {
                        enemy = {
                            ...baseEnemy,
                            hp: Math.floor(baseEnemy.hp * scale),
                            maxHp: Math.floor(baseEnemy.maxHp * scale),
                            atk: Math.floor(baseEnemy.atk * scale),
                            gold: Math.floor(baseEnemy.gold * scale),
                            exp: Math.floor(baseEnemy.exp * scale),
                            isBoss: false
                        };
                        
                        logMessage = `Encontrou ${enemy.name} Nv.${floor}!`;
                    }
                }

                this.setState({ 
                    enemy, 
                    screen: 'battle',
                    isPlayerTurn: true,
                    logs: [logMessage]
                });
            }

            attack() {
                return this.errorHandler.wrap(() => {
                    const { hero, enemy, isPlayerTurn } = this.state;
                    if (!enemy || !isPlayerTurn) {
                        console.log('Attack blocked:', { enemy: !!enemy, isPlayerTurn });
                        return;
                    }

                    console.log('Starting attack...');

                    // Salvar estado antes da a√ß√£o
                    this.stateManager.saveState(this.state);

                    // Aplicar buffs, equipamentos e status effects
                    const buffs = this.applyBuffs();
                    const totalStats = this.getTotalStats();
                    const statModifiers = this.getStatModifiers('hero');
                    const totalAtk = Math.floor((totalStats.atk + buffs.atk) * statModifiers.atk);

                    console.log('Attack stats:', { totalAtk, buffs, totalStats, statModifiers });

                    // Calcular chance de cr√≠tico com modifiers
                    const baseCritChance = 0.1;
                    const critChance = Math.min(0.5, baseCritChance * statModifiers.crit);
                    const isCrit = Math.random() < critChance;
                    
                    // Dano base
                    let damage = Math.floor(totalAtk * (isCrit ? 1.5 : 1));
                    const newEnemyHp = enemy.hp - damage;

                    console.log('Damage calculated:', { damage, isCrit, newEnemyHp });

                    // Adicionar anima√ß√£o de ataque na carta - fase 1: movimento at√© o inimigo
                    const heroCard = document.querySelector('.hero-card');
                    const enemyCard = document.querySelector('.enemy-card, .boss-card');
                    
                    if (heroCard) {
                        heroCard.classList.add('attacking');
                        
                        // Fase 2: anima√ß√£o de impacto no inimigo
                        setTimeout(() => {
                            if (enemyCard) {
                                enemyCard.classList.add('damaged');
                                enemyCard.classList.add('card-attack-hit');
                                
                                // Criar efeitos visuais no momento do impacto
                                if (this.settings.showDamageNumbers) {
                                    const rect = enemyCard.getBoundingClientRect();
                                    this.particleSystem.createDamageNumber(
                                        rect.left + rect.width / 2,
                                        rect.top,
                                        damage,
                                        isCrit
                                    );
                                }
                                
                                this.particleSystem.createEffect('attack', enemyCard);
                                
                                // Remover anima√ß√µes de impacto
                                setTimeout(() => {
                                    enemyCard.classList.remove('damaged');
                                    enemyCard.classList.remove('card-attack-hit');
                                }, 500);
                            }
                        }, 800); // Tempo quando a carta "encosta" na outra
                        
                        // Remover anima√ß√£o de ataque ap√≥s completar
                        setTimeout(() => {
                            heroCard.classList.remove('attacking');
                        }, 1200);
                    }

                    this.addLog(`Voc√™ atacou ${enemy.name} causando ${damage}${isCrit ? ' CR√çTICO!' : ''} de dano.`);

                    const newLimitBreak = Math.min(100, hero.limitBreak + 10);

                    if (newEnemyHp <= 0) {
                        // Parar auto-battle quando vencer
                        if (this.state.isAutoBattle) {
                            this.setState({ isAutoBattle: false });
                            if (this.autoBattleInterval) {
                                clearInterval(this.autoBattleInterval);
                                this.autoBattleInterval = null;
                            }
                        }
                        this.winBattle();
                    } else {
                        this.setState({
                            enemy: { ...enemy, hp: newEnemyHp },
                            hero: { ...hero, limitBreak: newLimitBreak },
                            isPlayerTurn: false
                        });
                        
                        // Atualizar HP das cartas
                        this.updateCardHP();
                        
                        setTimeout(() => this.enemyTurn(), 1000 / this.settings.animationSpeed);
                    }
                }, 'attack')();
            }

            limitBreak() {
                const { hero, enemy, isPlayerTurn } = this.state;
                if (!enemy || !isPlayerTurn || hero.limitBreak < 100) return;

                const damage = Math.floor(hero.atk * 3);
                const newEnemyHp = enemy.hp - damage;

                this.addLog(`LIMITE BREAK! Ataque massivo de ${damage} de dano!`);

                if (newEnemyHp <= 0) {
                    // Parar auto-battle quando vencer
                    if (this.state.isAutoBattle) {
                        this.setState({ isAutoBattle: false });
                        if (this.autoBattleInterval) {
                            clearInterval(this.autoBattleInterval);
                            this.autoBattleInterval = null;
                        }
                    }
                    this.winBattle();
                } else {
                    this.setState({
                        enemy: { ...enemy, hp: newEnemyHp },
                        hero: { ...hero, limitBreak: 0 },
                        isPlayerTurn: false
                    });
                    setTimeout(() => this.enemyTurn(), 1000);
                }
            }

            usePotion() {
                const { hero, enemy, isPlayerTurn } = this.state;
                if (!isPlayerTurn || hero.potions <= 0) {
                    this.addLog("Sem po√ß√µes!");
                    return;
                }

                // Salvar estado antes da a√ß√£o
                this.stateManager.saveState(this.state);

                const heal = Math.floor(hero.maxHp * 0.5);
                const newHp = Math.min(hero.maxHp, hero.hp + heal);

                // Adicionar anima√ß√£o de cura na carta
                const heroCard = document.querySelector('.hero-card');
                if (heroCard) {
                    heroCard.classList.add('healing');
                    setTimeout(() => heroCard.classList.remove('healing'), 800);
                }

                // Criar efeitos visuais de cura
                setTimeout(() => {
                    if (this.settings.showDamageNumbers) {
                        if (heroCard) {
                            const rect = heroCard.getBoundingClientRect();
                            this.particleSystem.createHealNumber(
                                rect.left + rect.width / 2,
                                rect.top,
                                heal
                            );
                        }
                    }
                    
                    this.particleSystem.createEffect('heal', heroCard);
                }, 400);

                this.addLog(`Usou Po√ß√£o. Curou ${heal} HP.`);

                this.setState({
                    hero: { ...hero, hp: newHp, potions: hero.potions - 1 },
                    isPlayerTurn: false
                });
                
                // Atualizar HP das cartas
                this.updateCardHP();
                
                // Pequeno delay antes do turno do inimigo para anima√ß√£o completa
                setTimeout(() => this.enemyTurn(), 1200);
            }

            updateCardHP() {
                // Atualizar barras de HP das cartas em tempo real
                setTimeout(() => {
                    const heroCard = document.querySelector('.hero-card');
                    const enemyCards = document.querySelectorAll('.enemy-card, .boss-card');
                    
                    // Atualizar HP do her√≥i
                    if (heroCard) {
                        const hpBar = heroCard.querySelector('.card-hp-fill');
                        const hpText = heroCard.querySelector('.card-hp-text');
                        if (hpBar && hpText) {
                            const { hero } = this.state;
                            const hpPercent = (hero.hp / hero.maxHp) * 100;
                            hpBar.style.width = `${hpPercent}%`;
                            hpText.textContent = `${hero.hp}/${hero.maxHp}`;
                        }
                    }
                    
                    // Atualizar HP dos inimigos (suporta m√∫ltiplos inimigos)
                    const { enemy } = this.state;
                    if (enemy && enemyCards.length > 0) {
                        // Se h√° m√∫ltiplos inimigos, gerar dados para cada um
                        const enemies = this.generateMultipleEnemies(enemy);
                        
                        enemyCards.forEach((card, index) => {
                            const hpBar = card.querySelector('.card-hp-fill');
                            const hpText = card.querySelector('.card-hp-text');
                            if (hpBar && hpText && enemies[index]) {
                                const enemyData = enemies[index];
                                const hpPercent = (enemyData.hp / enemyData.maxHp) * 100;
                                hpBar.style.width = `${hpPercent}%`;
                                hpText.textContent = `${enemyData.hp}/${enemyData.maxHp}`;
                            }
                        });
                    }
                }, 100);
            }

            enemyTurn() {
                const { hero, enemy } = this.state;
                if (!enemy) return;

                // Verificar se inimigo est√° desabilitado
                if (this.isDisabled('enemy')) {
                    this.addLog(`${enemy.name} est√° desabilitado e n√£o pode agir!`);
                    this.processStatusEffects();
                    this.decreaseBuffDuration();
                    this.decreaseSkillCooldowns();
                    this.setState({ isPlayerTurn: true });
                    return;
                }

                // Verificar se inimigo pode atacar
                if (this.isAttackDisabled('enemy')) {
                    this.addLog(`${enemy.name} n√£o pode atacar!`);
                    this.processStatusEffects();
                    this.decreaseBuffDuration();
                    this.decreaseSkillCooldowns();
                    this.setState({ isPlayerTurn: true });
                    return;
                }

                // Aplicar buffs, equipamentos e status effects
                const buffs = this.applyBuffs();
                const totalStats = this.getTotalStats();
                const statModifiers = this.getStatModifiers('hero');
                const totalDef = Math.floor((totalStats.def + buffs.def) * statModifiers.def);

                // Dano base do inimigo
                let damage = Math.max(1, enemy.atk - Math.floor(totalDef / 2));
                const newHp = hero.hp - damage;

                this.addLog(`${enemy.name} ataca! Voc√™ recebeu ${damage} de dano.`);

                // Adicionar anima√ß√£o de ataque do inimigo
                const enemyCards = document.querySelectorAll('.enemy-card, .boss-card');
                const heroCard = document.querySelector('.hero-card');
                
                if (enemyCards.length > 0 && heroCard) {
                    // Animar o primeiro inimigo atacando
                    const attackingEnemy = enemyCards[0];
                    attackingEnemy.classList.add('attacking');
                    
                    setTimeout(() => {
                        // Animar dano no her√≥i
                        heroCard.classList.add('damaged');
                        
                        // Criar efeitos visuais de dano
                        if (this.settings.showDamageNumbers) {
                            const rect = heroCard.getBoundingClientRect();
                            this.particleSystem.createDamageNumber(
                                rect.left + rect.width / 2,
                                rect.top,
                                damage,
                                false
                            );
                        }
                        
                        this.particleSystem.createEffect('damage', heroCard);
                        
                        setTimeout(() => {
                            heroCard.classList.remove('damaged');
                        }, 500);
                    }, 800);
                    
                    setTimeout(() => {
                        attackingEnemy.classList.remove('attacking');
                    }, 1200);
                }

                // Processar status effects e diminuir dura√ß√£o dos buffs
                this.processStatusEffects();
                this.decreaseBuffDuration();

                if (newHp <= 0) {
                    setTimeout(() => {
                        this.setState({
                            hero: { ...hero, hp: 0 },
                            screen: 'gameover'
                        });
                        // Atualizar HP das cartas
                        this.updateCardHP();
                    }, 1500);
                } else {
                    setTimeout(() => {
                        this.setState({
                            hero: { ...hero, hp: newHp },
                            isPlayerTurn: true
                        });
                        // Atualizar HP das cartas
                        this.updateCardHP();
                    }, 1500);
                }
            }

            winBattle() {
                const { hero, enemy, floor, gold } = this.state;
                if (!enemy) return;

                if (enemy.isBoss) {
                    this.addLog(`üéâ ${enemy.name} derrotado! Voc√™ √© um verdadeiro campe√£o!`);
                    this.bossConfetti();
                } else {
                    this.addLog(`üéâ ${enemy.name} derrotado!`);
                }

                // Gerar e coletar loot
                const loot = this.generateLoot(enemy.isBoss);
                this.collectLoot(loot);

                // Chance de ba√∫ misterioso
                if (Math.random() < 0.05) {
                    this.openChest();
                }

                // Adicionar experi√™ncia
                this.addExperience(enemy.exp);

                // Mostrar sele√ß√£o de caminhos ap√≥s vit√≥ria
                this.showPathSelection();

                const newFloor = floor + 1;
                const healAmount = Math.floor(hero.maxHp * 0.2);

                this.setState({
                    hero: {
                        ...hero,
                        hp: Math.min(hero.maxHp, hero.hp + healAmount)
                    },
                    gold: gold + enemy.gold,
                    floor: newFloor,
                    enemy: null
                });
            }

            toggleAutoBattle() {
                const newAutoBattle = !this.state.isAutoBattle;
                this.setState({ isAutoBattle: newAutoBattle });
                
                // Resetar flag quando desativar
                if (!newAutoBattle) {
                    this.isAutoBattleRunning = false;
                } else {
                    // Iniciar auto-battle quando ativado
                    this.startAutoBattleLoop();
                }
            }

            startAutoBattleLoop() {
                // Usar setInterval para compatibilidade
                if (this.autoBattleInterval) {
                    clearInterval(this.autoBattleInterval);
                }
                
                this.autoBattleInterval = setInterval(() => {
                    if (this.state.isAutoBattle && this.state.screen === 'battle' && this.state.isPlayerTurn && !this.isAutoBattleRunning) {
                        this.autoBattleLoop();
                    }
                }, 1000 / this.settings.animationSpeed);
            }

            // Auto battle loop
            autoBattleLoop() {
                if (!this.state.isAutoBattle || this.state.screen !== 'battle' || !this.state.isPlayerTurn || this.isAutoBattleRunning) {
                    return;
                }
                
                this.isAutoBattleRunning = true;
                
                const { hero, enemy } = this.state;
                
                // Verificar se inimigo ainda existe
                if (!enemy || enemy.hp <= 0) {
                    this.isAutoBattleRunning = false;
                    return;
                }
                
                console.log('Auto-battle executing action...');
                
                // Estrat√©gia de auto-battle
                if (hero.limitBreak >= 100) {
                    console.log('Auto-battle: Using Limit Break');
                    setTimeout(() => {
                        this.limitBreak();
                        this.isAutoBattleRunning = false;
                    }, 500);
                } else if (hero.hp < hero.maxHp * 0.3 && hero.potions > 0) {
                    console.log('Auto-battle: Using Potion');
                    setTimeout(() => {
                        this.usePotion();
                        this.isAutoBattleRunning = false;
                    }, 500);
                } else {
                    console.log('Auto-battle: Attacking');
                    setTimeout(() => {
                        this.attack();
                        this.isAutoBattleRunning = false;
                    }, 500);
                }
            }

            // ========== SHOP ==========
            buyItem(item) {
                const { hero, gold } = this.state;
                
                if (gold < item.cost) {
                    this.addLog("Ouro insuficiente!");
                    return;
                }

                let newHero = { ...hero };
                let message = `Comprou ${item.name}!`;

                switch(item.type) {
                    case 'potion':
                        newHero.potions++;
                        break;
                    case 'upgrade_atk':
                        newHero.atk += 2;
                        break;
                    case 'upgrade_def':
                        newHero.def += 2;
                        break;
                    case 'upgrade_hp':
                        newHero.maxHp += 20;
                        newHero.hp += 20;
                        break;
                }

                this.setState({
                    hero: newHero,
                    gold: gold - item.cost,
                    logs: [message, ...this.state.logs]
                });
            }

            // ========== CAMP SYSTEM ==========
            performCampAction(actionId) {
                const action = CAMP_ACTIONS.find(a => a.id === actionId);
                if (!action) return;

                const { gold } = this.state;
                if (gold < action.cost) {
                    this.addLog("Ouro insuficiente!");
                    return;
                }

                switch(action.effect) {
                    case 'full_heal':
                        this.rest();
                        break;
                    case 'limit_boost':
                        this.meditate();
                        break;
                    case 'upgrade_weapon':
                        this.forgeWeapon();
                        break;
                    case 'luck_boost':
                        this.ritualLuck();
                        break;
                    case 'temp_stats':
                        this.training();
                        break;
                    case 'open_craft':
                        this.showScreen('crafting');
                        return;
                }

                if (action.cost > 0) {
                    this.setState({ gold: gold - action.cost });
                }
            }

            rest() {
                const { hero } = this.state;
                this.setState({
                    hero: { ...hero, hp: hero.maxHp },
                    logs: ["üèïÔ∏è Descansou e recuperou toda a vida!", ...this.state.logs]
                });
            }

            meditate() {
                const { hero } = this.state;
                const newLimitBreak = Math.min(100, hero.limitBreak + 30);
                this.setState({
                    hero: { ...hero, limitBreak: newLimitBreak },
                    logs: ["üßò Meditou e aumentou o Limit Break!", ...this.state.logs]
                });
            }

            forgeWeapon() {
                const { hero } = this.state;
                const tempBuff = { type: 'weapon', atk: 5, duration: 3 };
                this.setState({
                    buffs: [...this.state.buffs, tempBuff],
                    logs: ["‚öîÔ∏è Arma temporariamente melhorada!", ...this.state.logs]
                });
            }

            ritualLuck() {
                this.setState({
                    luckBoost: 1.5,
                    logs: ["üçÄ Sorte aumentada para pr√≥ximas batalhas!", ...this.state.logs]
                });
            }

            training() {
                const { hero } = this.state;
                const tempBuff = { type: 'stats', atk: 5, def: 5, duration: 3 };
                this.setState({
                    buffs: [...this.state.buffs, tempBuff],
                    logs: ["üí™ Treinamento completo! Stats tempor√°rios aumentados!", ...this.state.logs]
                });
            }

            // ========== CRAFTING SYSTEM ==========
            canCraft(recipe) {
                return recipe.materials.every(mat => 
                    (this.state.materials[mat.id] || 0) >= mat.amount
                );
            }

            craftItem(recipeId) {
                const recipe = CRAFTING_RECIPES.find(r => r.id === recipeId);
                if (!recipe) return;

                if (!this.canCraft(recipe)) {
                    this.addLog("Materiais insuficientes!");
                    return;
                }

                // Remover materiais
                const materials = { ...this.state.materials };
                recipe.materials.forEach(mat => {
                    materials[mat.id] -= mat.amount;
                    if (materials[mat.id] === 0) delete materials[mat.id];
                });

                // Adicionar resultado ao invent√°rio
                const result = {
                    ...recipe.result,
                    name: recipe.name,
                    id: `crafted_${Date.now()}`
                };

                this.setState({
                    materials,
                    inventory: [...this.state.inventory, result]
                });

                this.addLog(`üî® Criou: ${recipe.name}!`);
            }

            // ========== EQUIPMENT STATS ==========
            getEquipmentStats() {
                const { equipment } = this.state;
                let totalStats = { atk: 0, def: 0 };
                
                Object.values(equipment).forEach(item => {
                    if (item && item.stats) {
                        totalStats.atk += item.stats.atk || 0;
                        totalStats.def += item.stats.def || 0;
                    }
                });
                
                return totalStats;
            }

            getTotalStats() {
                const { hero } = this.state;
                const equipmentStats = this.getEquipmentStats();
                const buffs = this.applyBuffs();
                
                return {
                    atk: hero.atk + equipmentStats.atk + buffs.atk,
                    def: hero.def + equipmentStats.def + buffs.def
                };
            }

            // ========== BUFF SYSTEM ==========
            applyBuffs() {
                let totalAtkBonus = 0;
                let totalDefBonus = 0;

                this.state.buffs.forEach(buff => {
                    if (buff.type === 'weapon' || buff.type === 'stats') {
                        totalAtkBonus += buff.atk || 0;
                    }
                    if (buff.type === 'stats') {
                        totalDefBonus += buff.def || 0;
                    }
                });

                return { atk: totalAtkBonus, def: totalDefBonus };
            }

            decreaseBuffDuration() {
                const buffs = this.state.buffs.map(buff => ({
                    ...buff,
                    duration: buff.duration - 1
                })).filter(buff => buff.duration > 0);

                if (buffs.length !== this.state.buffs.length) {
                    this.addLog("‚è∞ Alguns buffs expiraram!");
                }

                this.setState({ buffs });
            }

            // ========== MERCHANT SYSTEM ==========
            generateMerchant() {
                const name = MERCHANT_NAMES[Math.floor(Math.random() * MERCHANT_NAMES.length)];
                const stock = MERCHANT_STOCK.map(item => ({
                    ...item,
                    currentPrice: Math.floor(item.basePrice * (0.8 + Math.random() * 0.4)), // 20% varia√ß√£o
                    stock: Math.floor(Math.random() * 3) + 1 // 1-3 unidades
                }));

                return {
                    name,
                    stock,
                    discount: Math.random() < 0.3 ? 0.9 : 1, // 30% chance de 10% desconto
                    visitNumber: this.state.merchantVisit + 1
                };
            }

            visitMerchant() {
                if (!this.state.merchant) {
                    this.state.merchant = this.generateMerchant();
                    this.state.merchantVisit++;
                }
                this.showScreen('merchant');
            }

            buyFromMerchant(itemId) {
                const merchant = this.state.merchant;
                if (!merchant) return;

                const item = merchant.stock.find(i => i.id === itemId);
                if (!item || item.stock <= 0) {
                    this.addLog("Item fora de estoque!");
                    return;
                }

                const price = Math.floor(item.currentPrice * merchant.discount);
                if (this.state.gold < price) {
                    this.addLog("Ouro insuficiente!");
                    return;
                }

                // Adicionar ao invent√°rio
                const purchasedItem = {
                    ...item,
                    price,
                    purchased: true
                };
                delete purchasedItem.currentPrice;
                delete purchasedItem.stock;

                this.addToInventory(purchasedItem);

                // Atualizar estoque e ouro
                item.stock--;
                this.setState({
                    gold: this.state.gold - price,
                    merchant: { ...merchant }
                });

                this.addLog(`Comprou ${item.name} por ${price} Ouro!`);
            }

            sellToMerchant(itemIndex) {
                const merchant = this.state.merchant;
                if (!merchant) return;

                const item = this.state.inventory[itemIndex];
                if (!item) return;

                let sellPrice = 0;
                if (item.value) {
                    sellPrice = Math.floor(item.value * 0.6); // 60% do valor
                } else if (item.basePrice) {
                    sellPrice = Math.floor(item.basePrice * 0.5); // 50% do pre√ßo base
                } else {
                    sellPrice = Math.floor(Math.random() * 50) + 10; // Pre√ßo aleat√≥rio para itens sem valor
                }

                // Remover do invent√°rio
                const inventory = [...this.state.inventory];
                inventory.splice(itemIndex, 1);

                this.setState({
                    gold: this.state.gold + sellPrice,
                    inventory
                });

                this.addLog(`Vendeu ${item.name} por ${sellPrice} Ouro!`);
            }

            leaveMerchant() {
                this.setState({ merchant: null });
                this.showScreen('menu');
            }

            // ========== SKILLS SYSTEM ==========
            getAvailableSkills() {
                const { unlockedSkills, hero } = this.state;
                const allSkills = Object.keys(SKILLS_DATABASE);
                
                // Habilidades que ainda n√£o foram desbloqueadas
                return allSkills.filter(skillId => !unlockedSkills.includes(skillId));
            }

            generateSkillChoices() {
                const availableSkills = this.getAvailableSkills();
                
                if (availableSkills.length === 0) return [];
                
                // Selecionar 3 habilidades aleat√≥rias
                const shuffled = availableSkills.sort(() => Math.random() - 0.5);
                return shuffled.slice(0, 3).map(skillId => ({
                    id: skillId,
                    ...SKILLS_DATABASE[skillId]
                }));
            }

            showSkillSelection() {
                const choices = this.generateSkillChoices();
                
                if (choices.length === 0) {
                    this.addLog("Voc√™ j√° desbloqueou todas as habilidades!");
                    return;
                }
                
                this.setState({
                    skillChoices: choices,
                    screen: 'skillSelection'
                });
            }

            chooseSkill(skillId) {
                const { hero, unlockedSkills } = this.state;
                
                if (unlockedSkills.includes(skillId)) return;
                
                const skill = SKILLS_DATABASE[skillId];
                const newUnlockedSkills = [...unlockedSkills, skillId];
                
                this.setState({
                    hero: { ...hero, unlockedSkills: newUnlockedSkills },
                    skillChoices: null
                });
                
                this.addLog(`üîì Habilidade desbloqueada: ${skill.name}!`);
                this.showScreen('skills');
            }

            equipSkill(skillId, slotIndex) {
                const { equippedSkills, unlockedSkills } = this.state;
                
                if (slotIndex < 0 || slotIndex >= 5) return;
                if (!unlockedSkills.includes(skillId)) return;
                
                // Verificar se habilidade j√° est√° equipada
                const alreadyEquipped = equippedSkills.findIndex(id => id === skillId);
                if (alreadyEquipped !== -1) return;
                
                // Trocar habilidade
                const newEquippedSkills = [...equippedSkills];
                const oldSkill = newEquippedSkills[slotIndex];
                newEquippedSkills[slotIndex] = skillId;
                
                this.setState({
                    equippedSkills: newEquippedSkills
                });
                
                const skill = SKILLS_DATABASE[skillId];
                this.addLog(`‚ö° ${skill.name} equipada no slot ${slotIndex + 1}!`);
            }

            unequipSkill(slotIndex) {
                const { equippedSkills } = this.state;
                
                if (slotIndex < 0 || slotIndex >= 5) return;
                if (!equippedSkills[slotIndex]) return;
                
                const skill = SKILLS_DATABASE[equippedSkills[slotIndex]];
                const newEquippedSkills = [...equippedSkills];
                newEquippedSkills[slotIndex] = null;
                
                this.setState({
                    equippedSkills: newEquippedSkills
                });
                
                this.addLog(`‚ö° ${skill.name} removida do slot ${slotIndex + 1}!`);
            }

            useSkill(skillId) {
                const { hero, enemy, skillCooldowns, equippedSkills } = this.state;
                
                if (!equippedSkills.includes(skillId)) {
                    this.addLog("Habilidade n√£o est√° equipada!");
                    return;
                }
                
                if (skillCooldowns[skillId] && skillCooldowns[skillId] > 0) {
                    this.addLog(`Habilidade em cooldown: ${skillCooldowns[skillId]} turnos!`);
                    return;
                }
                
                const skill = SKILLS_DATABASE[skillId];
                this.executeSkillEffect(skill, skillId);
                
                // Adicionar cooldown
                const newCooldowns = { ...skillCooldowns };
                newCooldowns[skillId] = skill.cooldown;
                
                this.setState({
                    skillCooldowns: newCooldowns,
                    isPlayerTurn: false
                });
                
                setTimeout(() => this.enemyTurn(), 1000 / this.settings.animationSpeed);
            }

            winBattle() {
                const { hero, enemy } = this.state;
                
                // Parar auto-battle quando vencer
                if (this.state.isAutoBattle) {
                    this.setState({ isAutoBattle: false });
                    if (this.autoBattleInterval) {
                        clearInterval(this.autoBattleInterval);
                        this.autoBattleInterval = null;
                    }
                }
                
                // Ganhar XP e ouro
                const newExp = hero.exp + enemy.exp;
                const newGold = this.state.gold + enemy.gold;
                
                // Gerar loot
                const loot = this.generateLoot(enemy, enemy.isBoss);
                const lootMessages = this.collectLoot(loot);
                
                // Atualizar estado
                this.setState({
                    hero: { ...hero, exp: newExp },
                    gold: newGold,
                    enemy: null,
                    logs: [
                        `üéâ Vit√≥ria! Ganhou ${enemy.exp} XP e ${enemy.gold} Ouro!`,
                        ...lootMessages.map(msg => `üì¶ ${msg}`),
                        ...this.state.logs
                    ]
                });
                
                // Verificar level up
                if (newExp >= XP_CURVE.getRequiredXP(hero.level + 1)) {
                    setTimeout(() => this.levelUp(), 1000);
                }
                
                // Verificar se √© chefe e oferece escolha de classe
                if (enemy.isBoss) {
                    // Marcar primeiro chefe como derrotado se ainda n√£o foi
                    const updatedHero = { ...hero };
                    if (!hero.hasDefeatedFirstBoss) {
                        updatedHero.hasDefeatedFirstBoss = true;
                        this.setState({ hero: updatedHero });
                    }
                    
                    setTimeout(() => {
                        if (this.checkForClassEvolution()) {
                            return; // Para a continua√ß√£o se houver evolu√ß√£o dispon√≠vel
                        }
                        this.continueToNextStage();
                    }, 2000);
                } else {
                    // Continuar para o pr√≥ximo est√°gio ap√≥s a vit√≥ria normal
                    setTimeout(() => {
                        this.continueToNextStage();
                    }, 2000);
                }
            }

            performDoubleAttack() {
                const { enemy } = this.state;
                const totalStats = this.getTotalStats();
                const damage = Math.floor(totalStats.atk * 0.7);
                
                this.addLog(`Golpe duplo! Primeiro ataque: ${damage} de dano`);
                // Implementar l√≥gica de dano...
            }

            performCriticalAttack() {
                this.addLog("Golpe cr√≠tico ativado! Pr√≥ximo ataque tem 25% de chance de cr√≠tico");
                // Implementar l√≥gica...
            }

            activateBerserkMode() {
                this.addLog("F√∫ria berserker ativada! +50% ATK, -10 DEF por 3 turnos");
                // Implementar l√≥gica...
            }

            performUltimateAttack() {
                const totalStats = this.getTotalStats();
                const damage = Math.floor(totalStats.atk * 2);
                this.addLog(`Ataque supremo! ${damage} de dano massivo!`);
                // Implementar l√≥gica...
            }

            applyPoison() {
                this.addLog("Lamina venenosa! Inimigo envenenado");
                // Implementar l√≥gica...
            }

            activateCounterAttack() {
                this.addLog("Contra-ataque ativado! Pr√≥ximo dano ser√° refletido");
                // Implementar l√≥gica...
            }

            activateDefenseBoost() {
                this.addLog("Postura defensiva! +50% DEF por 2 turnos");
                // Implementar l√≥gica...
            }

            activateDivineShield() {
                this.addLog("Escudo divino! Pr√≥ximo ataque ser√° bloqueado");
                // Implementar l√≥gica...
            }

            activateHealBoost() {
                this.addLog("Cura aprimorada! +50% efic√°cia em po√ß√µes");
                // Implementar l√≥gica...
            }

            activateLootBoost() {
                this.addLog("Sorte do ca√ßador ativada! +30% chance de loot raro");
                // Implementar l√≥gica...
            }

            decreaseSkillCooldowns() {
                const { skillCooldowns } = this.state;
                const newCooldowns = {};
                
                Object.entries(skillCooldowns).forEach(([skillId, cooldown]) => {
                    if (cooldown > 1) {
                        newCooldowns[skillId] = cooldown - 1;
                    }
                });
                
                this.setState({ skillCooldowns: newCooldowns });
            }

            showSkillsScreen() {
                this.showScreen('skills');
            }

            // ========== ELEMENTAL & STATUS SYSTEM ==========
            calculateElementalDamage(attackElement, targetElement, baseDamage) {
                if (!attackElement || !targetElement || attackElement === 'physical' || targetElement === 'physical') {
                    return baseDamage;
                }

                const attacker = ELEMENTS[attackElement];
                const defender = ELEMENTS[targetElement];

                // Strong vs Weak = 1.5x damage
                if (attacker.strong === defender.name.toLowerCase()) {
                    return Math.floor(baseDamage * 1.5);
                }

                // Weak vs Strong = 0.7x damage
                if (attacker.weak === defender.name.toLowerCase()) {
                    return Math.floor(baseDamage * 0.7);
                }

                return baseDamage;
            }

            applyResistance(damage, targetResistances, attackElement) {
                if (!targetResistances || !attackElement || attackElement === 'physical') {
                    return damage;
                }

                const resistance = targetResistances[attackElement];
                if (resistance) {
                    return Math.floor(damage * resistance);
                }

                return damage;
            }

            applyStatusEffect(target, statusType, duration = null) {
                const { statusEffects, enemy } = this.state;
                const status = STATUS_EFFECTS[statusType];
                
                if (!status) return;

                // Verificar imunidade
                const targetEntity = target === 'hero' ? 'hero' : enemy;
                if (targetEntity.statusImmune && targetEntity.statusImmune.includes(statusType)) {
                    this.addLog(`${targetEntity.name} √© imune a ${status.name}!`);
                    return;
                }

                // Verificar se j√° tem o status
                const existingStatus = statusEffects[target].find(s => s.type === statusType);
                if (existingStatus) {
                    // Resetar dura√ß√£o
                    existingStatus.duration = duration || status.duration;
                    this.addLog(`${status.name} mantido em ${target}!`);
                    return;
                }

                // Adicionar novo status
                const newStatus = {
                    type: statusType,
                    name: status.name,
                    icon: status.icon,
                    color: status.color,
                    duration: duration || status.duration,
                    effect: status.effect,
                    damage: status.damage || false,
                    heal: status.heal || false,
                    disable: status.disable || false,
                    buff: status.buff || false,
                    debuff: status.debuff || false
                };

                const newStatusEffects = { ...statusEffects };
                newStatusEffects[target] = [...newStatusEffects[target], newStatus];

                this.setState({ statusEffects: newStatusEffects });
                this.addLog(`${target} recebeu ${status.name}!`);
            }

            processStatusEffects() {
                const { statusEffects, hero, enemy } = this.state;
                const newStatusEffects = { hero: [], enemy: [] };

                // Processar status do her√≥i
                statusEffects.hero.forEach(status => {
                    this.applyStatusEffectLogic(status, 'hero', hero);
                    
                    // Reduzir dura√ß√£o
                    if (status.duration > 1) {
                        newStatusEffects.hero.push({ ...status, duration: status.duration - 1 });
                    } else {
                        this.addLog(`${status.name} do her√≥i acabou!`);
                    }
                });

                // Processar status do inimigo
                if (enemy) {
                    statusEffects.enemy.forEach(status => {
                        this.applyStatusEffectLogic(status, 'enemy', enemy);
                        
                        // Reduzir dura√ß√£o
                        if (status.duration > 1) {
                            newStatusEffects.enemy.push({ ...status, duration: status.duration - 1 });
                        } else {
                            this.addLog(`${status.name} do inimigo acabou!`);
                        }
                    });
                }

                this.setState({ statusEffects: newStatusEffects });
            }

            applyStatusEffectLogic(status, target, entity) {
                switch (status.effect) {
                    case 'damage_per_turn':
                        const damage = Math.floor(entity.maxHp * 0.05); // 5% do HP m√°ximo
                        const newHp = Math.max(1, entity.hp - damage);
                        this.setState({
                            [target]: { ...entity, hp: newHp }
                        });
                        this.addLog(`${status.name}: ${damage} de dano!`);
                        break;

                    case 'heal_per_turn':
                        const heal = Math.floor(entity.maxHp * 0.08); // 8% do HP m√°ximo
                        const newHp2 = Math.min(entity.maxHp, entity.hp + heal);
                        this.setState({
                            [target]: { ...entity, hp: newHp2 }
                        });
                        this.addLog(`${status.name}: +${heal} HP!`);
                        break;

                    case 'disable_attack':
                        // L√≥gica implementada no turno do inimigo
                        break;

                    case 'disable_all':
                        // L√≥gica implementada no turno do inimigo
                        break;

                    case 'damage_reduction':
                        // L√≥gica implementada no c√°lculo de dano
                        break;

                    case 'atk_boost_def_reduction':
                        // L√≥gica implementada no c√°lculo de stats
                        break;

                    case 'critical_boost':
                        // L√≥gica implementada no c√°lculo de cr√≠tico
                        break;

                    case 'stats_reduction':
                        // L√≥gica implementada no c√°lculo de stats
                        break;
                }
            }

            hasStatusEffect(target, statusType) {
                const { statusEffects } = this.state;
                return statusEffects[target].some(status => status.type === statusType);
            }

            isDisabled(target) {
                const { statusEffects } = this.state;
                return statusEffects[target].some(status => 
                    status.disable && status.effect === 'disable_all'
                );
            }

            isAttackDisabled(target) {
                const { statusEffects } = this.state;
                return statusEffects[target].some(status => 
                    status.disable && (status.effect === 'disable_all' || status.effect === 'disable_attack')
                );
            }

            getDamageReduction(target) {
                const { statusEffects } = this.state;
                let reduction = 0;
                
                statusEffects[target].forEach(status => {
                    if (status.effect === 'damage_reduction') {
                        reduction += 0.5; // 50% de redu√ß√£o
                    }
                });
                
                return Math.min(reduction, 0.9); // M√°ximo 90% de redu√ß√£o
            }

            getStatModifiers(target) {
                const { statusEffects } = this.state;
                let atkMod = 1.0;
                let defMod = 1.0;
                let critMod = 1.0;
                
                statusEffects[target].forEach(status => {
                    switch (status.effect) {
                        case 'atk_boost_def_reduction':
                            atkMod += 0.5;
                            defMod -= 0.2;
                            break;
                        case 'stats_reduction':
                            atkMod -= 0.3;
                            defMod -= 0.3;
                            break;
                        case 'critical_boost':
                            critMod += 1.0;
                            break;
                    }
                });
                
                return {
                    atk: Math.max(0.1, atkMod),
                    def: Math.max(0.1, defMod),
                    crit: Math.max(0.1, critMod)
                };
            }

            // ========== POST-BATTLE PATH SYSTEM ==========
            generatePathOptions() {
                const options = [];
                const pathTypes = Object.keys(PATH_TYPES);
                
                // Gerar 3 op√ß√µes de caminho
                for (let i = 0; i < 3; i++) {
                    const pathType = this.selectWeightedPathType();
                    options.push({
                        id: i,
                        type: pathType,
                        ...PATH_TYPES[pathType]
                    });
                }
                
                // Garantir pelo menos uma op√ß√£o de combate
                if (!options.some(opt => opt.type === 'combat')) {
                    options[0] = {
                        id: 0,
                        type: 'combat',
                        ...PATH_TYPES.combat
                    };
                }
                
                // Embaralhar op√ß√µes
                return options.sort(() => Math.random() - 0.5);
            }

            selectWeightedPathType() {
                const pathTypes = Object.keys(PATH_TYPES);
                const totalWeight = pathTypes.reduce((sum, type) => sum + PATH_TYPES[type].weight, 0);
                let random = Math.random() * totalWeight;
                
                for (const type of pathTypes) {
                    random -= PATH_TYPES[type].weight;
                    if (random <= 0) {
                        return type;
                    }
                }
                
                return 'combat';
            }

            showPathSelection() {
                const paths = this.generatePathOptions();
                this.setState({
                    currentPaths: paths,
                    pathSelection: true,
                    screen: 'pathSelection'
                });
            }

            selectPath(pathId) {
                const path = this.state.currentPaths.find(p => p.id === pathId);
                if (!path) return;
                
                // Mostrar tela de revela√ß√£o
                this.showPathReveal(path);
            }

            showPathReveal(path) {
                this.setState({
                    selectedPath: path,
                    screen: 'pathReveal'
                });
                
                // Mostrar o que foi escolhido
                this.addLog(`üó∫Ô∏è Voc√™ escolheu: ${path.icon} ${path.name} - ${path.description}`);
                
                // Executar a a√ß√£o ap√≥s 2 segundos
                setTimeout(() => {
                    this.resolvePathChoice(path);
                }, 2000);
            }

            resolvePathChoice(path) {
                this.setState({ pathSelection: false });
                
                switch (path.type) {
                    case 'combat':
                        this.startPathCombat();
                        break;
                    case 'treasure':
                        this.openTreasureChest();
                        break;
                    case 'healing':
                        this.useHealingFountain();
                        break;
                    case 'mystery':
                        this.resolveMysteryPath();
                        break;
                    case 'empty':
                        this.addLog('‚ùå N√£o h√° nada por aqui...');
                        this.continueToNextStage();
                        break;
                }
            }

            continueToNextStage() {
                // Avan√ßar para o pr√≥ximo est√°gio diretamente
                const { floor } = this.state;
                const newFloor = floor + 1;
                
                this.setState({ floor: newFloor });
                this.addLog(`üìç Avan√ßando para o est√°gio ${newFloor}!`);
                
                // Pequeno delay antes de mostrar novos caminhos
                setTimeout(() => {
                    this.showPathSelection();
                }, 1500);
            }

            startPathCombat() {
                // Iniciar novo combate com inimigos aleat√≥rios
                this.startBattle();
                this.addLog('‚öîÔ∏è Voc√™ encontrou mais inimigos!');
            }

            openTreasureChest() {
                const rewards = PATH_REWARDS.treasure;
                let totalGold = Math.floor(Math.random() * (rewards.gold.max - rewards.gold.min + 1)) + rewards.gold.min;
                
                this.setState({ gold: this.state.gold + totalGold });
                this.addLog(`üì¶ Ba√∫ aberto! +${totalGold} Ouro`);
                
                // Chance de item extra
                if (Math.random() < rewards.items.chance) {
                    const rarity = rewards.items.rarity[Math.floor(Math.random() * rewards.items.rarity.length)];
                    const item = this.generateEquipment(this.state.floor, rarity);
                    if (item) {
                        this.addToInventory(item);
                        this.addLog(`+${item.name} encontrado!`);
                    }
                }
                
                // Continuar para o pr√≥ximo est√°gio ap√≥s coletar o tesouro
                setTimeout(() => {
                    this.continueToNextStage();
                }, 1000);
            }

            useHealingFountain() {
                const { hero } = this.state;
                const healPercentage = PATH_REWARDS.healing.heal.percentage;
                const healAmount = Math.floor(hero.maxHp * healPercentage);
                const newHp = Math.min(hero.maxHp, hero.hp + healAmount);
                
                this.setState({
                    hero: { ...hero, hp: newHp }
                });
                
                this.addLog(`üíö Fonte de cura! +${healAmount} HP`);
                
                // Continuar para o pr√≥ximo est√°gio ap√≥s usar a fonte
                setTimeout(() => {
                    this.continueToNextStage();
                }, 1000);
            }

            resolveMysteryPath() {
                const outcomes = PATH_REWARDS.mystery.random.outcomes;
                const outcome = outcomes[Math.floor(Math.random() * outcomes.length)];
                
                switch (outcome.type) {
                    case 'gold':
                        this.setState({ gold: this.state.gold + outcome.amount });
                        this.addLog(`‚ùì Evento misterioso! +${outcome.amount} Ouro`);
                        break;
                    case 'item':
                        const item = this.generateEquipment(this.state.floor, outcome.rarity);
                        if (item) {
                            this.addToInventory(item);
                            this.addLog(`‚ùì Evento misterioso! +${item.name}`);
                        }
                        break;
                    case 'heal':
                        const { hero } = this.state;
                        const healAmount = Math.floor(hero.maxHp * outcome.percentage);
                        const newHp = Math.min(hero.maxHp, hero.hp + healAmount);
                        this.setState({ hero: { ...hero, hp: newHp } });
                        this.addLog(`‚ùì Evento misterioso! +${healAmount} HP`);
                        break;
                    case 'damage':
                        const damage = Math.floor(hero.maxHp * outcome.percentage);
                        const newHp2 = Math.max(1, hero.hp - damage);
                        this.setState({ hero: { ...hero, hp: newHp2 } });
                        this.addLog(`‚ùì Evento misterioso! -${damage} HP`);
                        break;
                }
                
                // Continuar para o pr√≥ximo est√°gio ap√≥s resolver o mist√©rio
                setTimeout(() => {
                    this.continueToNextStage();
                }, 1000);
            }

            getRandomEquipment(rarity = null) {
                const itemKeys = Object.keys(EQUIPMENT_ITEMS);
                let availableItems = itemKeys;
                
                if (rarity) {
                    availableItems = itemKeys.filter(key => 
                        EQUIPMENT_ITEMS[key].rarity === rarity
                    );
                }
                
                if (availableItems.length === 0) return null;
                
                const randomKey = availableItems[Math.floor(Math.random() * availableItems.length)];
                return this.generateEquipmentItem(randomKey);
            }

            showEquipmentScreen() {
                this.showScreen('equipment');
            }

            // ========== EXPERIENCE SYSTEM ==========
            addExperience(amount) {
                const { hero } = this.state;
                if (hero.level >= hero.maxLevel) {
                    this.addLog("Voc√™ j√° est√° no n√≠vel m√°ximo!");
                    return;
                }

                const newExp = hero.exp + amount;
                const newTotalExp = hero.totalExp + amount;
                const requiredXP = XP_CURVE.getRequiredXP(hero.level + 1);

                this.setState({
                    hero: { ...hero, exp: newExp, totalExp: newTotalExp }
                });

                // Verificar se subiu de n√≠vel
                if (newExp >= requiredXP) {
                    this.levelUp();
                }
            }

            levelUp() {
                const { hero } = this.state;
                const newLevel = Math.min(hero.level + 1, hero.maxLevel);
                
                if (newLevel === hero.level) return;

                // Calcular XP excedente
                const requiredXP = XP_CURVE.getRequiredXP(hero.level + 1);
                const excessXP = hero.exp - requiredXP;
                
                // Aplicar stats da classe no novo n√≠vel
                const classStats = this.getClassStats(hero.class, newLevel);
                const currentClassStats = this.getClassStats(hero.class, hero.level);
                
                // Calcular diferen√ßa de stats
                const hpDiff = classStats.hp - currentClassStats.hp;
                const atkDiff = classStats.atk - currentClassStats.atk;
                const defDiff = classStats.def - currentClassStats.def;
                
                // Aplicar recompensas do n√≠vel
                const rewards = LEVEL_REWARDS[newLevel];
                if (rewards) {
                    this.applyLevelRewards(rewards, newLevel);
                }

                // Atualizar estado com stats da classe + recompensas
                const updatedHero = {
                    ...hero,
                    level: newLevel,
                    exp: excessXP,
                    maxHp: classStats.hp + (rewards?.rewards?.hp || 0),
                    atk: classStats.atk + (rewards?.rewards?.atk || 0),
                    def: classStats.def + (rewards?.rewards?.def || 0),
                    potions: hero.potions + (rewards?.rewards?.potions || 0),
                    hp: classStats.hp + (rewards?.rewards?.hp || 0) // Cura completa ao subir de n√≠vel
                };

                this.setState({ hero: updatedHero });

                // Verificar evolu√ß√µes de classe nos n√≠veis 20 e 40
                if (newLevel === 20 || newLevel === 40) {
                    setTimeout(() => {
                        if (this.checkForClassEvolution()) {
                            return; // Para se houver evolu√ß√£o dispon√≠vel
                        }
                    }, 1500);
                }

                // Mostrar sele√ß√£o de habilidades a partir do n√≠vel 2
                if (newLevel >= 2 && this.getAvailableSkills().length > 0) {
                    setTimeout(() => {
                        this.showSkillSelection();
                    }, 2000);
                }

                // Efeitos visuais
                this.showLevelUpEffect(rewards);
            }

            applyLevelRewards(rewards, level) {
                const { rewards: statRewards } = rewards;
                
                let message = `üéâ LEVEL UP! N√≠vel ${level} alcan√ßado!\n`;
                message += `${rewards.message}\n`;
                
                if (statRewards.hp > 0) message += `+${statRewards.hp} HP M√°ximo\n`;
                if (statRewards.atk > 0) message += `+${statRewards.atk} ATK\n`;
                if (statRewards.def > 0) message += `+${statRewards.def} DEF\n`;
                if (statRewards.potions > 0) message += `+${statRewards.potions} Po√ß√µes\n`;
                
                this.addLog(message);
            }

            unlockSkills(level) {
                const newSkills = SKILLS[level] || [];
                if (newSkills.length > 0) {
                    const { hero } = this.state;
                    const updatedSkills = [...hero.skills, ...newSkills];
                    
                    this.setState({
                        hero: { ...hero, skills: updatedSkills }
                    });

                    this.addLog(`üîì Habilidades desbloqueadas: ${newSkills.join(', ')}`);
                }
            }

            showLevelUpEffect(rewards) {
                // Criar efeito visual de level up
                const levelUpDiv = document.createElement('div');
                levelUpDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #f1c40f, #e74c3c);
                    color: white;
                    padding: 20px 40px;
                    border-radius: 15px;
                    font-size: 16px;
                    font-weight: bold;
                    z-index: 10000;
                    animation: levelUpPulse 2s ease-in-out;
                    text-align: center;
                    box-shadow: 0 0 30px rgba(241, 196, 15, 0.8);
                `;
                
                levelUpDiv.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 10px;">‚¨ÜÔ∏è LEVEL UP! ‚¨ÜÔ∏è</div>
                    <div>${rewards.message}</div>
                `;
                
                document.body.appendChild(levelUpDiv);
                
                // Remover ap√≥s anima√ß√£o
                setTimeout(() => {
                    document.body.removeChild(levelUpDiv);
                }, 2000);

                // Adicionar CSS da anima√ß√£o se n√£o existir
                if (!document.getElementById('levelUpStyles')) {
                    const style = document.createElement('style');
                    style.id = 'levelUpStyles';
                    style.textContent = `
                        @keyframes levelUpPulse {
                            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            getXPProgress() {
                const { hero } = this.state;
                if (hero.level >= hero.maxLevel) return 100;
                
                const currentLevelXP = XP_CURVE.getRequiredXP(hero.level);
                const nextLevelXP = XP_CURVE.getRequiredXP(hero.level + 1);
                const progress = ((hero.exp - currentLevelXP) / (nextLevelXP - currentLevelXP)) * 100;
                
                return Math.max(0, Math.min(100, progress));
            }

            getXPToNextLevel() {
                const { hero } = this.state;
                if (hero.level >= hero.maxLevel) return 0;
                
                const nextLevelXP = XP_CURVE.getRequiredXP(hero.level + 1);
                return nextLevelXP - hero.exp;
            }

            // ========== CONFETTI ==========
            confetti() {
                // Simple confetti effect using DOM manipulation
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.style.position = 'fixed';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.top = '-10px';
                    confetti.style.width = '10px';
                    confetti.style.height = '10px';
                    confetti.style.background = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71'][Math.floor(Math.random() * 4)];
                    confetti.style.zIndex = '10000';
                    confetti.style.pointerEvents = 'none';
                    document.body.appendChild(confetti);

                    const duration = 2000 + Math.random() * 1000;
                    const distance = 300 + Math.random() * 200;
                    
                    confetti.animate([
                        { transform: 'translateY(0) rotate(0deg)', opacity: 1 },
                        { transform: `translateY(${distance}px) rotate(${Math.random() * 720}deg)`, opacity: 0 }
                    ], {
                        duration,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    });

                    setTimeout(() => confetti.remove(), duration);
                }
            }

            bossConfetti() {
                // Confetti especial para chefes com mais efeitos
                for (let i = 0; i < 100; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.style.position = 'fixed';
                        confetti.style.left = Math.random() * 100 + '%';
                        confetti.style.top = '-10px';
                        confetti.style.width = '15px';
                        confetti.style.height = '15px';
                        confetti.style.background = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#e67e22'][Math.floor(Math.random() * 6)];
                        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                        confetti.style.zIndex = '10000';
                        confetti.style.pointerEvents = 'none';
                        confetti.style.boxShadow = `0 0 10px ${confetti.style.background}`;
                        document.body.appendChild(confetti);

                        const duration = 3000 + Math.random() * 1500;
                        const distance = 400 + Math.random() * 300;
                        
                        confetti.animate([
                            { transform: 'translateY(0) rotate(0deg) scale(1)', opacity: 1 },
                            { transform: `translateY(${distance}px) rotate(${Math.random() * 1080}deg) scale(0.5)`, opacity: 0 }
                        ], {
                            duration,
                            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                        });

                        setTimeout(() => confetti.remove(), duration);
                    }, i * 30);
                }

                // Adicionar texto de vit√≥ria
                const victoryText = document.createElement('div');
                victoryText.style.position = 'fixed';
                victoryText.style.top = '50%';
                victoryText.style.left = '50%';
                victoryText.style.transform = 'translate(-50%, -50%)';
                victoryText.style.fontSize = '48px';
                victoryText.style.fontWeight = 'bold';
                victoryText.style.color = '#f1c40f';
                victoryText.style.textShadow = '3px 3px 6px rgba(0,0,0,0.8)';
                victoryText.style.zIndex = '10001';
                victoryText.style.pointerEvents = 'none';
                victoryText.textContent = 'üèÜ VIT√ìRIA! üèÜ';
                victoryText.style.fontFamily = "'Press Start 2P', cursive";
                document.body.appendChild(victoryText);

                victoryText.animate([
                    { transform: 'translate(-50%, -50%) scale(0) rotate(0deg)', opacity: 0 },
                    { transform: 'translate(-50%, -50%) scale(1.2) rotate(5deg)', opacity: 1 },
                    { transform: 'translate(-50%, -50%) scale(1) rotate(0deg)', opacity: 1 },
                    { transform: 'translate(-50%, -50%) scale(1) rotate(-3deg)', opacity: 1 },
                    { transform: 'translate(-50%, -50%) scale(1) rotate(0deg)', opacity: 0 }
                ], {
                    duration: 3000,
                    easing: 'ease-in-out'
                });

                setTimeout(() => victoryText.remove(), 3000);
            }

            render() {
                return this.errorHandler.wrap(() => {
                    const app = document.getElementById('app');
                    if (!app) return;

                    // Iniciar monitoramento
                    this.performanceMonitor.startRender();

                    // Validar estado
                    if (!Utils.validateState(this.state)) {
                        throw new GameError('Estado do jogo inv√°lido', 'INVALID_STATE');
                    }

                    // Verificar se estado mudou significativamente
                    const currentStateHash = this.getStateHash();
                    if (this.lastRenderState === currentStateHash) {
                        return; // Skip render se estado n√£o mudou
                    }
                    this.lastRenderState = currentStateHash;

                    const { screen } = this.state;

                    // Usar cache para renders est√°ticos
                    let content;
                    const cacheKey = `${screen}_${currentStateHash}`;
                    
                    if (this.renderCache.has(cacheKey)) {
                        content = this.renderCache.get(cacheKey);
                    } else {
                        content = this.renderScreen(screen);
                        this.renderCache.set(cacheKey, content);
                        
                        // Limitar cache size
                        if (this.renderCache.size > 50) {
                            const firstKey = this.renderCache.keys().next().value;
                            this.renderCache.delete(firstKey);
                        }
                    }

                    app.innerHTML = content;
                    
                    // Finalizar monitoramento
                    this.performanceMonitor.endRender();
                }, 'render')();
            }

            renderScreen(screen) {
                switch (screen) {
                    case 'home': return this.renderHome();
                    case 'menu': return this.renderMenu();
                    case 'battle': return this.renderBattle();
                    case 'victory': return this.renderVictory();
                    case 'gameover': return this.renderGameOver();
                    case 'shop': return this.renderShop();
                    case 'crafting': return this.renderCrafting();
                    case 'merchant': return this.renderMerchant();
                    case 'pathSelection': return this.renderPathSelection();
                    case 'pathReveal': return this.renderPathReveal();
                    case 'equipment': return this.renderEquipment();
                    case 'inventory': return this.renderInventory();
                    case 'skills': return this.renderSkills();
                    case 'skillSelection': return this.renderSkillSelection();
                    case 'classSelection': return this.renderClassSelection();
                    case 'stats': return this.renderStats();
                    case 'settings': return this.renderSettings();
                    default: return '<div>Screen not found</div>';
                }
            }

            getStateHash() {
                // Hash simplificado para detectar mudan√ßas relevantes
                const { screen, hero, enemy, isPlayerTurn, isAutoBattle } = this.state;
                return `${screen}_${hero.hp}_${hero.level}_${enemy?.hp}_${isPlayerTurn}_${isAutoBattle}`;
            }

            renderHome() {
                const hasSave = localStorage.getItem('pixelquest_save');
                return `
                    <div class="home-screen">
                        <div class="container">
                            <div class="window home-window">
                                <h1 class="title text-gold">PIXEL QUEST</h1>
                                <p class="subtitle">UMA AVENTURA RPG EM REACT</p>
                                
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <label style="font-size: 10px; color: #3498db; display: block; margin-bottom: 10px;">
                                        DIGITE O NOME DO HER√ìI
                                    </label>
                                    <input 
                                        type="text" 
                                        id="hero-name" 
                                        class="input" 
                                        placeholder="JOGADOR UM"
                                        maxlength="12"
                                        autofocus
                                    >
                                </div>

                                <button class="btn" onclick="game.startNewGame()">
                                    ‚öîÔ∏è NOVO JOGO
                                </button>

                                ${hasSave ? `
                                    <button class="btn" onclick="game.continueGame()">
                                        üíæ CONTINUAR
                                    </button>
                                ` : ''}

                                <div style="text-align: center; margin-top: 30px; font-size: 8px; color: #666;">
                                    <p>v1.0.0 ‚Ä¢ HTML/CSS/JS Edition</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            startNewGame() {
                const name = document.getElementById('hero-name').value;
                this.startGame(name || 'Hero');
            }

            continueGame() {
                this.showScreen('menu');
            }

            renderMenu() {
                const { hero, floor, gold } = this.state;
                const hasMerchant = Math.random() < 0.3; // 30% chance de mercador

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <div style="text-align: center; margin-bottom: 20px;">
                                <div style="font-size: 60px;">üè∞</div>
                                <h2 class="text-gold" style="font-size: 18px;">O QUE VOC√ä FAR√Å?</h2>
                            </div>

                            <button class="btn" onclick="game.startBattle()">
                                ‚öîÔ∏è AVENTURAR-SE
                            </button>

                            <button class="btn" onclick="game.showScreen('shop')">
                                üè™ MERCADOR LOCAL
                            </button>

                            ${hasMerchant ? `
                                <button class="btn text-purple" style="border-color: #9b59b6;" onclick="game.visitMerchant()">
                                    üõí MERCADOR VIAJANTE
                                </button>
                            ` : ''}

                            <button class="btn" onclick="game.showScreen('equipment')">
                                üéí EQUIPAMENTOS
                            </button>

                            <button class="btn" onclick="game.showScreen('inventory')">
                                üéí ITENS
                            </button>

                            <button class="btn" onclick="game.showScreen('skills')">
                                ‚ö° HABILIDADES
                            </button>

                            <button class="btn" onclick="game.showScreen('stats')">
                                üìä VER STATUS
                            </button>

                            <button class="btn" onclick="game.showScreen('settings')">
                                ‚öôÔ∏è CONFIGURA√á√ïES
                            </button>

                            <button class="btn text-blue" onclick="game.debugSystem()" style="margin-top: 10px;">
                                üîç DEBUG
                            </button>

                            <button class="btn text-red" onclick="game.resetGame()" style="margin-top: 10px;">
                                üîÑ RESETAR TUDO
                            </button>
                        </div>

                        ${this.renderLog()}
                    </div>
                `;
            }

            generateMultipleEnemies(baseEnemy) {
                const enemies = [];
                
                if (!baseEnemy.enemyCount || baseEnemy.enemyCount <= 1) {
                    return [baseEnemy];
                }
                
                // Criar m√∫ltiplas c√≥pias do inimigo
                for (let i = 0; i < baseEnemy.enemyCount; i++) {
                    const enemyCopy = {
                        ...baseEnemy,
                        hp: baseEnemy.maxHp, // Cada inimigo tem HP cheio
                        enemyCount: 1, // Individual
                        id: i // ID √∫nico para cada um
                    };
                    enemies.push(enemyCopy);
                }
                
                return enemies;
            }

            renderBattle() {
                const { hero, enemy, isPlayerTurn, isAutoBattle } = this.state;

                // Gerar m√∫ltiplos inimigos se necess√°rio
                const enemies = this.generateMultipleEnemies(enemy);
                const cardSize = enemies.length > 1 ? 'small' : 'normal';

                return `
                    <div class="container">
                        ${this.renderHeader()}

                        <div class="game-grid">
                            ${this.renderStatsPanel()}

                            <div>
                                <div class="window window-red">
                                    <div class="battle-arena ${enemies.length > 1 ? 'multiple-enemies' : ''}">
                                        <div class="text-center">
                                            ${renderCard(hero, 'hero', isPlayerTurn, this)}
                                            ${isPlayerTurn ? '<div style="font-size: 20px; color: var(--ff-gold); margin-top: 10px;">‚ñº SEU TURNO</div>' : ''}
                                        </div>

                                        <div class="vs-text">VS</div>

                                        <div class="enemies-container">
                                            ${enemies.map((enemyData, index) => `
                                                <div class="text-center enemy-card-wrapper">
                                                    ${renderCard(enemyData, enemyData.isBoss ? 'boss' : 'enemy', !isPlayerTurn, this, cardSize)}
                                                    ${enemyData.enemyCount && enemyData.enemyCount > 1 ? `<div style="position: absolute; top: -10px; right: -10px; background: var(--ff-red); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">${enemyData.enemyCount}</div>` : ''}
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>

                                    <div class="battle-controls">
                                        <button class="btn" onclick="game.attack()" ${!isPlayerTurn ? 'disabled' : ''}>
                                            ‚öîÔ∏è ATACAR
                                        </button>

                                        <button 
                                            class="btn ${hero.limitBreak >= 100 ? 'pulse text-purple' : ''}" 
                                            onclick="game.limitBreak()" 
                                            ${!isPlayerTurn || hero.limitBreak < 100 ? 'disabled' : ''}
                                        >
                                            ‚ö° LIMITE BREAK
                                        </button>

                                        <button class="btn" onclick="game.usePotion()" ${!isPlayerTurn || hero.potions === 0 ? 'disabled' : ''}>
                                            üß™ PO√á√ÉO (${hero.potions})
                                        </button>

                                        <button 
                                            class="btn ${isAutoBattle ? 'text-green' : ''}" 
                                            onclick="game.toggleAutoBattle()"
                                        >
                                            ${isAutoBattle ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'} AUTO: ${isAutoBattle ? 'ON' : 'OFF'}
                                        </button>
                                    </div>
                                </div>

                                ${this.renderLog()}
                            </div>
                        </div>
                    </div>
                `;
            }

            renderVictory() {
                return `
                    <div class="container">
                        <div class="window">
                            <div class="result-screen">
                                <h2 class="result-title text-gold">VIT√ìRIA!</h2>
                                <div class="result-icon">üèÜ</div>
                                <p class="text-green">O inimigo foi derrotado.</p>
                                <button class="btn" onclick="game.showPathSelection()" style="max-width: 300px; margin-top: 20px;">
                                    üó∫Ô∏è ESCOLHER CAMINHO
                                </button>
                                <button class="btn" onclick="game.showScreen('menu')" style="max-width: 300px; margin-top: 10px;">
                                    üè™ VOLTAR AO MENU
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderGameOver() {
                return `
                    <div class="container">
                        <div class="window window-red">
                            <div class="result-screen">
                                <h2 class="result-title text-red">GAME OVER</h2>
                                <div class="result-icon">‚ò†Ô∏è</div>
                                <p style="color: #999;">Sua jornada termina aqui...</p>
                                <button class="btn" onclick="game.showScreen('menu')" style="max-width: 300px; margin-top: 20px;">
                                    üîÑ VOLTAR AO MENU
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderShop() {
                const { gold } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}

                        <div class="window">
                            <h2 class="text-gold text-center" style="margin-bottom: 20px;">
                                üè™ MERCADOR GOBLIN
                            </h2>
                            <div style="text-align: center; font-size: 10px; color: #999; margin-bottom: 20px;">
                                Ouro Dispon√≠vel: <span class="text-gold">${gold}G</span>
                            </div>

                            <div class="shop-grid">
                                ${SHOP_ITEMS.map(item => `
                                    <button 
                                        class="btn shop-item" 
                                        onclick='game.buyItem(${JSON.stringify(item)})'
                                        ${gold < item.cost ? 'disabled' : ''}
                                    >
                                        <span>${item.name}</span>
                                        <span class="text-gold">${item.cost}G</span>
                                    </button>
                                `).join('')}
                            </div>

                            <button class="btn mt-4" onclick="game.showScreen('menu')">
                                ‚óÄÔ∏è VOLTAR
                            </button>
                        </div>

                        ${this.renderLog()}
                    </div>
                `;
            }

            renderCamp() {
                const { hero, gold, buffs, materials } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}

                        <div class="window">
                            <div class="text-center">
                                <h2 class="text-green">üèïÔ∏è ACAMPAMENTO</h2>
                                <div style="font-size: 80px; margin: 20px 0;">üî•</div>
                                <p style="font-size: 10px; color: #999; margin-bottom: 20px;">
                                    Descanse e prepare-se para as pr√≥ximas batalhas.
                                </p>

                                <div style="margin-bottom: 20px;">
                                    <div style="font-size: 8px; color: #999;">BUFFS ATIVOS:</div>
                                    ${buffs.length > 0 ? buffs.map(buff => 
                                        `<div style="font-size: 8px; color: var(--ff-green);">
                                            ${buff.type === 'weapon' ? '‚öîÔ∏è' : 'üí™'} ${buff.duration} batalhas restantes
                                        </div>`
                                    ).join('') : '<div style="font-size: 8px; color: #666;">Nenhum buff ativo</div>'}
                                </div>

                                <div class="shop-grid">
                                    ${CAMP_ACTIONS.map(action => `
                                        <button 
                                            class="btn shop-item" 
                                            onclick='game.performCampAction("${action.id}")'
                                            ${gold < action.cost ? 'disabled' : ''}
                                        >
                                            <span>${action.name}</span>
                                            <span>${action.cost > 0 ? action.cost + 'G' : 'GR√ÅTIS'}</span>
                                        </button>
                                    `).join('')}
                                </div>

                                <div style="margin-top: 20px; font-size: 8px; color: #666;">
                                    <div>MATERIAIS COLETADOS: ${Object.keys(materials).length}</div>
                                    <div>OURO DISPON√çVEL: ${gold}G</div>
                                </div>

                                <button class="btn mt-4" onclick="game.showScreen('menu')">
                                    ‚óÄÔ∏è VOLTAR
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderClassSelection() {
                const { hero, availableClasses } = this.state;
                const isEvolution = hero.level >= 20;
                
                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <h2 class="text-gold" style="font-size: 20px;">
                                    ${isEvolution ? '‚≠ê EVOLU√á√ÉO DE CLASSE' : 'üé≠ ESCOLHA SUA CLASSE'}
                                </h2>
                                <p style="font-size: 12px; color: #ccc; margin-top: 10px;">
                                    ${isEvolution 
                                        ? `Sua classe atual: ${CLASS_SYSTEM[hero.class]?.icon || 'üéì'} ${CLASS_SYSTEM[hero.class]?.name || hero.class}`
                                        : 'Escolha sua especializa√ß√£o:'
                                    }
                                </p>
                            </div>

                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                                ${availableClasses.map(className => {
                                    const classData = CLASS_SYSTEM[className];
                                    const currentStats = this.getClassStats(hero.class, hero.level);
                                    const newStats = this.getClassStats(className, hero.level);
                                    
                                    return `
                                        <div style="
                                            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
                                            border: 2px solid #444;
                                            border-radius: 12px;
                                            padding: 20px;
                                            text-align: center;
                                            cursor: pointer;
                                            transition: all 0.3s ease;
                                        " onmouseover="this.style.borderColor='#ffd700'; this.style.transform='translateY(-5px)'" 
                                           onmouseout="this.style.borderColor='#444'; this.style.transform='translateY(0)'"
                                           onclick="game.selectClass('${className}')">
                                            <div style="font-size: 48px; margin-bottom: 15px;">${classData.icon}</div>
                                            <h3 style="color: #ffd700; margin-bottom: 10px; font-size: 16px;">${classData.name}</h3>
                                            <p style="color: #ccc; font-size: 10px; margin-bottom: 15px; line-height: 1.4;">${classData.description}</p>
                                            
                                            <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 10px; margin-bottom: 15px;">
                                                <div style="font-size: 10px; color: #999; margin-bottom: 8px;">Stats no N√≠vel ${hero.level}:</div>
                                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 9px;">
                                                    <div>
                                                        <span style="color: #e74c3c;">‚ù§Ô∏è ${newStats.hp}</span>
                                                        ${newStats.hp > currentStats.hp ? '<span style="color: #2ecc71;"> (+)</span>' : ''}
                                                    </div>
                                                    <div>
                                                        <span style="color: #f39c12;">‚öîÔ∏è ${newStats.atk}</span>
                                                        ${newStats.atk > currentStats.atk ? '<span style="color: #2ecc71;"> (+)</span>' : ''}
                                                    </div>
                                                    <div>
                                                        <span style="color: #3498db;">üõ°Ô∏è ${newStats.def}</span>
                                                        ${newStats.def > currentStats.def ? '<span style="color: #2ecc71;"> (+)</span>' : ''}
                                                    </div>
                                                    <div>
                                                        <span style="color: #9b59b6;">üìà N√≠vel ${hero.level}</span>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            ${classData.skills.length > 0 ? `
                                                <div style="font-size: 9px; color: #999; margin-bottom: 5px;">Habilidades:</div>
                                                <div style="display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;">
                                                    ${classData.skills.map(skill => `
                                                        <span style="
                                                            background: rgba(155, 89, 182, 0.3);
                                                            color: #9b59b6;
                                                            padding: 2px 6px;
                                                            border-radius: 4px;
                                                            font-size: 8px;
                                                        ">${skill.replace(/_/g, ' ')}</span>
                                                    `).join('')}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>

                            <div style="text-align: center;">
                                <button class="btn" onclick="game.showScreen('menu')" style="margin-right: 10px;">
                                    ‚ùå CANCELAR
                                </button>
                            </div>
                        </div>

                        ${this.renderLog()}
                    </div>
                `;
            }

            selectClass(className) {
                this.changeClass(className);
                this.showScreen('menu');
            }

            renderStats() {
                const { hero, floor, gold } = this.state;
                const expNeeded = hero.level * 100;

                return `
                    <div class="container">
                        ${this.renderHeader()}

                        <div class="window">
                            <h2 class="text-gold text-center mb-4">üìä STATUS DO HER√ìI</h2>

                            <div class="stats-panel">
                                <div class="stat-row">
                                    <span>NOME:</span>
                                    <span class="text-gold">${hero.name}</span>
                                </div>
                                <div class="stat-row">
                                    <span>N√çVEL:</span>
                                    <span class="text-gold">${hero.level}</span>
                                </div>
                                <div class="stat-row">
                                    <span>HP:</span>
                                    <span class="text-green">${hero.hp} / ${hero.maxHp}</span>
                                </div>
                                <div class="stat-row">
                                    <span>ATAQUE:</span>
                                    <span class="text-red">${hero.atk}</span>
                                </div>
                                <div class="stat-row">
                                    <span>DEFESA:</span>
                                    <span class="text-purple">${hero.def}</span>
                                </div>
                                <div class="stat-row">
                                    <span>EXP:</span>
                                    <span>${hero.exp} / ${expNeeded}</span>
                                </div>
                                <div class="stat-row">
                                    <span>LIMITE BREAK:</span>
                                    <span class="text-purple">${hero.limitBreak}%</span>
                                </div>
                                <div class="stat-row">
                                    <span>PO√á√ïES:</span>
                                    <span class="text-green">${hero.potions}</span>
                                </div>
                                <div class="stat-row">
                                    <span>√âTERES:</span>
                                    <span class="text-purple">${hero.ethers}</span>
                                </div>
                            </div>

                            <button class="btn mt-4" onclick="game.showScreen('menu')">
                                ‚óÄÔ∏è VOLTAR
                            </button>
                        </div>
                    </div>
                `;
            }

            renderHeader() {
                const { floor, gold } = this.state;

                return `
                    <div class="window header">
                        <div>
                            <div class="header-stat">ANDAR</div>
                            <div class="header-value text-gold">${floor}</div>
                        </div>
                        <div class="text-center" style="display: none;">
                            <h3 class="text-gold">Pixel Quest</h3>
                        </div>
                        <div style="text-align: right;">
                            <div class="header-stat">OURO</div>
                            <div class="header-value text-gold">${gold}</div>
                        </div>
                    </div>
                `;
            }

            renderStatsPanel() {
                const { hero } = this.state;
                const hpPercent = (hero.hp / hero.maxHp) * 100;
                const limitPercent = hero.limitBreak;
                const expNeeded = hero.level * 100;

                return `
                    <div class="stats-panel">
                        <div style="text-align: center; margin-bottom: 15px;">
                            <div style="font-size: 14px; color: var(--ff-gold);">${hero.name}</div>
                            <div style="font-size: 10px; color: #999;">N√≠vel ${hero.level}</div>
                        </div>

                        <div>
                            <div style="font-size: 8px; color: #999; margin-bottom: 3px;">HP</div>
                            <div class="hp-bar" style="width: 150px; height: 8px; margin: 5px auto;">
                                <div class="hp-fill" style="width: ${(hero.hp / hero.maxHp) * 100}%; height: 100%;"></div>
                                <div class="bar-text">${hero.hp} / ${hero.maxHp}</div>
                            </div>
                            
                            <!-- Barra de XP -->
                            <div style="font-size: 8px; color: #f1c40f; margin-top: 5px;">
                                LVL ${hero.level} ${hero.level >= hero.maxLevel ? 'üëë' : ''}
                            </div>
                            <div class="xp-bar" style="width: 150px; height: 6px; margin: 3px auto;">
                                <div class="xp-fill" style="width: ${this.getXPProgress()}%; height: 100%;"></div>
                                <div class="bar-text" style="font-size: 6px;">
                                    ${hero.level >= hero.maxLevel ? 'MAX' : `${this.getXPToNextLevel()} XP`}
                                </div>
                            </div>

                            <div style="font-size: 8px; color: #999; margin-bottom: 3px;">LIMITE BREAK</div>
                            <div class="limit-bar">
                                <div class="limit-fill" style="width: ${limitPercent}%"></div>
                                <div class="bar-text">${limitPercent}%</div>
                            </div>
                        </div>

                        <div class="stat-row mt-4">
                            <span>ATK:</span>
                            <span class="text-red">${hero.atk}</span>
                        </div>
                        <div class="stat-row">
                            <span>DEF:</span>
                            <span class="text-purple">${hero.def}</span>
                        </div>
                        <div class="stat-row">
                            <span>EXP:</span>
                            <span>${hero.exp}/${expNeeded}</span>
                        </div>
                        <div class="stat-row">
                            <span>PO√á√ïES:</span>
                            <span class="text-green">${hero.potions}</span>
                        </div>
                    </div>
                `;
            }

            renderLog() {
                const { logs } = this.state;

                return `
                    <div class="log mt-4">
                        ${logs.map((log, i) => `
                            <div class="log-entry">${log}</div>
                        `).join('')}
                    </div>
                `;
            }

            renderSettings() {
                const { settings } = this;
                
                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <h2 class="text-gold text-center mb-4">‚öôÔ∏è CONFIGURA√á√ïES</h2>
                            
                            <div class="stats-panel">
                                <div class="stat-row">
                                    <span>VELOCIDADE DAS ANIMA√á√ïES:</span>
                                    <select id="anim-speed" class="input" style="width: 100px;">
                                        <option value="0.5" ${settings.animationSpeed === 0.5 ? 'selected' : ''}>0.5x</option>
                                        <option value="1" ${settings.animationSpeed === 1 ? 'selected' : ''}>1x</option>
                                        <option value="1.5" ${settings.animationSpeed === 1.5 ? 'selected' : ''}>1.5x</option>
                                        <option value="2" ${settings.animationSpeed === 2 ? 'selected' : ''}>2x</option>
                                    </select>
                                </div>
                                
                                <div class="stat-row">
                                    <span>MOSTRAR N√öMEROS DE DANO:</span>
                                    <input type="checkbox" id="show-damage" ${settings.showDamageNumbers ? 'checked' : ''}>
                                </div>
                                
                                <div class="stat-row">
                                    <span>AUTO-SAVE (segundos):</span>
                                    <input type="number" id="auto-save" class="input" style="width: 100px;" 
                                           value="${settings.autoSaveInterval / 1000}" min="10" max="300">
                                </div>
                            </div>
                            
                            <button class="btn mt-4" onclick="game.saveSettingsFromForm()">
                                üíæ SALVAR CONFIGURA√á√ïES
                            </button>
                            
                            <button class="btn mt-2" onclick="game.showScreen('menu')">
                                ‚óÄÔ∏è VOLTAR
                            </button>
                        </div>
                    </div>
                `;
            }

            saveSettingsFromForm() {
                const animSpeed = parseFloat(document.getElementById('anim-speed').value);
                const showDamage = document.getElementById('show-damage').checked;
                const autoSave = parseInt(document.getElementById('auto-save').value) * 1000;
                
                this.updateSettings({
                    animationSpeed: animSpeed,
                    showDamageNumbers: showDamage,
                    autoSaveInterval: autoSave
                });
                
                this.addLog('Configura√ß√µes salvas!');
                this.showScreen('menu');
            }

            renderCrafting() {
                const { materials } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <h2 class="text-gold text-center mb-4">üî® CRAFTING</h2>
                            
                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: var(--ff-green); margin-bottom: 10px;">MATERIAIS DISPON√çVEIS:</h3>
                                ${Object.keys(materials).length > 0 ? Object.entries(materials).map(([id, amount]) => {
                                    const material = MATERIALS.find(m => m.id === id);
                                    return material ? `
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 10px;">
                                            <span>${material.icon} ${material.name}</span>
                                            <span style="color: ${LOOT_TIERS[material.rarity].color};">${amount}</span>
                                        </div>
                                    ` : '';
                                }).join('') : '<div style="font-size: 10px; color: #666;">Nenhum material dispon√≠vel</div>'}
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: var(--ff-gold); margin-bottom: 10px;">RECEITAS:</h3>
                                ${CRAFTING_RECIPES.map(recipe => {
                                    const canCraft = this.canCraft(recipe);
                                    return `
                                        <div class="shop-item" style="margin-bottom: 10px; padding: 10px; border: 2px solid ${canCraft ? '#2ecc71' : '#666'}; border-radius: 4px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                                <span style="font-size: 10px;">${recipe.name}</span>
                                                <button 
                                                    class="btn" 
                                                    style="padding: 8px 12px; font-size: 8px;"
                                                    onclick='game.craftItem("${recipe.id}")'
                                                    ${!canCraft ? 'disabled' : ''}
                                                >
                                                    üî® CRIAR
                                                </button>
                                            </div>
                                            <div style="font-size: 8px; color: #999;">
                                                ${recipe.materials.map(mat => {
                                                    const material = MATERIALS.find(m => m.id === mat.id);
                                                    const hasAmount = materials[mat.id] || 0;
                                                    const enough = hasAmount >= mat.amount;
                                                    return `${material.icon} ${mat.amount} ${material.name} <span style="color: ${enough ? '#2ecc71' : '#e74c3c'}">(${hasAmount}/${mat.amount})</span>`;
                                                }).join(' | ')}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            
                            <button class="btn" onclick="game.showScreen('camp')">
                                ‚óÄÔ∏è VOLTAR AO ACAMPAMENTO
                            </button>
                        </div>
                    </div>
                `;
            }

            renderMerchant() {
                const { merchant, gold, inventory } = this.state;

                if (!merchant) {
                    return `
                        <div class="container">
                            ${this.renderHeader()}
                            <div class="window">
                                <h2 class="text-gold text-center">Nenhum mercador dispon√≠vel</h2>
                                <button class="btn" onclick="game.showScreen('menu')">‚óÄÔ∏è VOLTAR</button>
                            </div>
                        </div>
                    `;
                }

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <h2 class="text-gold text-center mb-4">üõí ${merchant.name}</h2>
                            
                            ${merchant.discount < 1 ? `
                                <div style="text-align: center; margin-bottom: 15px;">
                                    <span style="color: var(--ff-green); font-size: 10px;">üéâ DESCONTO ESPECIAL DE 10%!</span>
                                </div>
                            ` : ''}

                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: var(--ff-gold); margin-bottom: 10px;">ITENS √Ä VENDA:</h3>
                                ${merchant.stock.map(item => {
                                    const price = Math.floor(item.currentPrice * merchant.discount);
                                    const canAfford = gold >= price;
                                    return `
                                        <div class="shop-item" style="margin-bottom: 8px; opacity: ${item.stock > 0 ? 1 : 0.5};">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="font-size: 10px;">
                                                    ${item.name} ${item.stock > 0 ? `(x${item.stock})` : '(Esgotado)'}
                                                </span>
                                                <div style="display: flex; align-items: center; gap: 8px;">
                                                    <span style="color: ${canAfford ? 'var(--ff-gold)' : 'var(--ff-red)'}; font-size: 10px;">
                                                        ${price}G ${merchant.discount < 1 ? '‚¨áÔ∏è' : ''}
                                                    </span>
                                                    <button 
                                                        class="btn" 
                                                        style="padding: 6px 10px; font-size: 8px;"
                                                        onclick='game.buyFromMerchant("${item.id}")'
                                                        ${!canAfford || item.stock <= 0 ? 'disabled' : ''}
                                                    >
                                                        COMPRAR
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>

                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: var(--ff-purple); margin-bottom: 10px;">SEUS ITENS:</h3>
                                ${inventory.length > 0 ? inventory.map((item, index) => {
                                    let sellPrice = 0;
                                    if (item.value) sellPrice = Math.floor(item.value * 0.6);
                                    else if (item.basePrice) sellPrice = Math.floor(item.basePrice * 0.5);
                                    else sellPrice = Math.floor(Math.random() * 50) + 10;

                                    return `
                                        <div class="shop-item" style="margin-bottom: 8px;">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="font-size: 10px;">${item.name}</span>
                                                <div style="display: flex; align-items: center; gap: 8px;">
                                                    <span style="color: var(--ff-gold); font-size: 10px;">{sellPrice}G</span>
                                                    <button 
                                                        class="btn" 
                                                        style="padding: 6px 10px; font-size: 8px;"
                                                        onclick='game.sellToMerchant(${index})'
                                                    >
                                                        VENDER
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('') : '<div style="font-size: 10px; color: #666;">Nenhum item para vender</div>'}
                            </div>
                            
                            <div style="text-align: center; margin-top: 20px; font-size: 10px; color: #999;">
                                Ouro dispon√≠vel: ${gold}G
                            </div>
                            
                            <button class="btn mt-4" onclick="game.leaveMerchant()">
                                üëã SAIR
                            </button>
                        </div>
                    </div>
                `;
            }

            renderPathSelection() {
                const { currentPaths, hero } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <h2 class="text-gold" style="font-size: 18px; margin-bottom: 10px;">
                                    üó∫Ô∏è ESCOLHA SEU CAMINHO
                                </h2>
                                <p style="font-size: 10px; color: #999; margin-bottom: 15px;">
                                    O que voc√™ encontrar√° adiante?
                                </p>
                                <div style="font-size: 8px; color: #999;">
                                    HP: ${hero.hp}/${hero.maxHp}
                                </div>
                            </div>

                            <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 30px;">
                                ${currentPaths.map((path, index) => `
                                    <div style="
                                        width: 120px;
                                        height: 140px;
                                        border: 3px solid #666;
                                        border-radius: 12px;
                                        display: flex;
                                        flex-direction: column;
                                        align-items: center;
                                        justify-content: center;
                                        background: #222;
                                        cursor: pointer;
                                        transition: all 0.3s;
                                        padding: 10px;
                                    "
                                    onclick="game.selectPath(${path.id})"
                                    onmouseover="this.style.transform='scale(1.05)'; this.style.background='#333'; this.style.borderColor='#999';"
                                    onmouseout="this.style.transform='scale(1)'; this.style.background='#222'; this.style.borderColor='#666';"
                                    >
                                        <div style="font-size: 48px; margin-bottom: 8px; color: #666;">
                                            ?
                                        </div>
                                        <div style="font-size: 10px; color: #999; font-weight: bold; margin-bottom: 4px; text-align: center;">
                                            CAMINHO ${index + 1}
                                        </div>
                                        <div style="font-size: 7px; color: #666; text-align: center; line-height: 1.2;">
                                            Clique para escolher
                                        </div>
                                    </div>
                                `).join('')}
                            </div>

                            <div style="text-align: center; margin-bottom: 20px;">
                                <p style="font-size: 8px; color: #666;">
                                    üí° Dica: Cada caminho √© um mist√©rio. Escolha com sabedoria!
                                </p>
                            </div>

                            <div style="display: flex; gap: 10px;">
                                <button class="btn" onclick="game.showScreen('menu')" style="flex: 1;">
                                    üîô VOLTAR
                                </button>
                            </div>

                            ${this.renderLog()}
                        </div>
                    </div>
                `;
            }

            renderPathReveal() {
                const { selectedPath, hero } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <h2 class="text-gold" style="font-size: 18px; margin-bottom: 10px;">
                                    üó∫Ô∏è CAMINHO REVELADO!
                                </h2>
                                <p style="font-size: 10px; color: #999; margin-bottom: 15px;">
                                    Voc√™ escolheu seu destino...
                                </p>
                                <div style="font-size: 8px; color: #999;">
                                    HP: ${hero.hp}/${hero.maxHp}
                                </div>
                            </div>

                            <div style="display: flex; justify-content: center; margin-bottom: 30px;">
                                <div style="
                                    width: 180px;
                                    height: 200px;
                                    border: 4px solid ${selectedPath.color};
                                    border-radius: 16px;
                                    display: flex;
                                    flex-direction: column;
                                    align-items: center;
                                    justify-content: center;
                                    background: ${selectedPath.color}20;
                                    padding: 20px;
                                    animation: pulse 1s infinite;
                                ">
                                    <div style="font-size: 64px; margin-bottom: 12px;">
                                        ${selectedPath.icon}
                                    </div>
                                    <div style="font-size: 14px; color: ${selectedPath.color}; font-weight: bold; margin-bottom: 8px; text-align: center;">
                                        ${selectedPath.name}
                                    </div>
                                    <div style="font-size: 10px; color: #fff; text-align: center; line-height: 1.4;">
                                        ${selectedPath.description}
                                    </div>
                                </div>
                            </div>

                            <div style="text-align: center; margin-bottom: 20px;">
                                <p style="font-size: 10px; color: ${selectedPath.color}; font-weight: bold;">
                                    Preparando-se para enfrentar o destino...
                                </p>
                                <div style="font-size: 8px; color: #666; margin-top: 5px;">
                                    Executando em 2 segundos...
                                </div>
                            </div>

                            ${this.renderLog()}
                        </div>
                    </div>
                `;
            }

            equipItem(index) {
                const { inventory, equipment } = this.state;
                const item = inventory[index];
                
                if (!item) return;
                
                // Verificar se √© um item equip√°vel
                if (!['weapon', 'armor', 'accessory'].includes(item.type)) {
                    this.addLog('‚ùå Este item n√£o pode ser equipado!');
                    return;
                }
                
                // Guardar item atual equipado (se houver)
                const currentItem = equipment[item.type];
                
                // Equipar novo item
                this.setState({
                    equipment: { ...equipment, [item.type]: item },
                    inventory: inventory.filter((_, i) => i !== index)
                });
                
                // Se havia um item equipado, voltar para o invent√°rio
                if (currentItem) {
                    this.setState({
                        inventory: [...this.state.inventory, currentItem]
                    });
                }
                
                this.addLog(`‚öîÔ∏è ${item.name} equipado!`);
            }

            sellItem(index) {
                const { inventory, gold } = this.state;
                const item = inventory[index];
                
                if (!item) return;
                
                // Calcular valor de venda (25% do valor original)
                const sellValue = Math.floor((item.value || 50) * 0.25);
                
                this.setState({
                    inventory: inventory.filter((_, i) => i !== index),
                    gold: gold + sellValue
                });
                
                this.addLog(`üí∞ ${item.name} vendido por ${sellValue} ouro!`);
            }

            renderInventory() {
                const { inventory } = this.state;
                
                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <div style="text-align: center; margin-bottom: 20px;">
                                <h2 class="text-gold" style="font-size: 18px;">üéí INVENT√ÅRIO</h2>
                                <p style="font-size: 10px; color: #999;">Itens encontrados em suas aventuras</p>
                            </div>

                            <div style="max-height: 400px; overflow-y: auto;">
                                ${inventory.length === 0 ? `
                                    <div style="text-align: center; padding: 40px; color: #666;">
                                        <div style="font-size: 48px; margin-bottom: 10px;">üéí</div>
                                        <p>Invent√°rio vazio</p>
                                        <p style="font-size: 8px;">Encontre itens em batalhas e tesouros!</p>
                                    </div>
                                ` : inventory.map((item, index) => `
                                    <div style="
                                        background: rgba(255,255,255,0.05);
                                        border: 1px solid #444;
                                        border-radius: 8px;
                                        padding: 12px;
                                        margin-bottom: 10px;
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                    ">
                                        <div style="flex: 1;">
                                            <div style="font-size: 12px; font-weight: bold; color: ${item.rarity === 'legendary' ? '#f39c12' : item.rarity === 'epic' ? '#9b59b6' : item.rarity === 'rare' ? '#3498db' : '#95a5a6'};">
                                                ${item.name}
                                            </div>
                                            <div style="font-size: 8px; color: #999; margin-top: 2px;">
                                                ${item.type} ‚Ä¢ ${item.rarity}
                                            </div>
                                            ${item.stats ? `
                                                <div style="font-size: 8px; color: #ccc; margin-top: 4px;">
                                                    ${item.stats.atk ? `‚öîÔ∏è +${item.stats.atk} ` : ''}
                                                    ${item.stats.def ? `üõ°Ô∏è +${item.stats.def}` : ''}
                                                </div>
                                            ` : ''}
                                        </div>
                                        <div style="display: flex; gap: 5px;">
                                            ${item.type === 'weapon' || item.type === 'armor' || item.type === 'accessory' ? `
                                                <button 
                                                    class="btn" 
                                                    style="padding: 4px 8px; font-size: 8px;"
                                                    onclick="game.equipItem(${index})"
                                                >
                                                    ‚öîÔ∏è EQUIPAR
                                                </button>
                                            ` : ''}
                                            <button 
                                                class="btn" 
                                                style="padding: 4px 8px; font-size: 8px; background: #e74c3c;"
                                                onclick="game.sellItem(${index})"
                                            >
                                                üí∞ VENDER
                                            </button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>

                            <button class="btn mt-4" onclick="game.showScreen('menu')">
                                ‚óÄÔ∏è VOLTAR
                            </button>
                        </div>

                        ${this.renderLog()}
                    </div>
                `;
            }

            renderEquipment() {
                const { equipment, inventory, hero } = this.state;
                const equipmentStats = this.getEquipmentStats();
                const totalStats = this.getTotalStats();

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <h2 class="text-gold text-center mb-4">üéí EQUIPAMENTOS</h2>
                            
                            <!-- Stats Atuais -->
                            <div style="text-align: center; margin-bottom: 20px; padding: 10px; background: #111; border-radius: 8px;">
                                <div style="font-size: 10px; color: #999; margin-bottom: 5px;">STATS TOTAIS</div>
                                <div style="display: flex; justify-content: center; gap: 20px;">
                                    <div>
                                        <span style="color: #e74c3c;">ATK: ${totalStats.atk}</span>
                                        ${equipmentStats.atk > 0 ? `<span style="color: #2ecc71; font-size: 8px;">(+${equipmentStats.atk})</span>` : ''}
                                    </div>
                                    <div>
                                        <span style="color: #3498db;">DEF: ${totalStats.def}</span>
                                        ${equipmentStats.def > 0 ? `<span style="color: #2ecc71; font-size: 8px;">(+${equipmentStats.def})</span>` : ''}
                                    </div>
                                </div>
                            </div>

                            <!-- Slots de Equipamento -->
                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: #f1c40f; margin-bottom: 10px;">EQUIPADOS</h3>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                    ${Object.entries(EQUIPMENT_SLOTS).map(([slotKey, slotInfo]) => {
                                        const equippedItem = equipment[slotKey];
                                        return `
                                            <div style="
                                                border: 2px solid ${slotInfo.color};
                                                border-radius: 8px;
                                                padding: 10px;
                                                text-align: center;
                                                background: ${equippedItem ? slotInfo.color + '20' : '#111'};
                                            ">
                                                <div style="font-size: 16px; margin-bottom: 5px;">${slotInfo.icon}</div>
                                                <div style="font-size: 8px; color: ${slotInfo.color}; margin-bottom: 5px;">${slotInfo.name}</div>
                                                ${equippedItem ? `
                                                    <div style="font-size: 7px; color: ${RARITY_COLORS[equippedItem.rarity]}; margin-bottom: 3px;">
                                                        ${equippedItem.name}
                                                    </div>
                                                    <div style="font-size: 6px; color: #999;">
                                                        ${equippedItem.stats.atk > 0 ? `ATK+${equippedItem.stats.atk} ` : ''}
                                                        ${equippedItem.stats.def > 0 ? `DEF+${equippedItem.stats.def}` : ''}
                                                    </div>
                                                    <button 
                                                        class="btn" 
                                                        style="padding: 4px 8px; font-size: 6px; margin-top: 5px;"
                                                        onclick="game.unequipItem('${slotKey}')"
                                                    >
                                                        DESEQUIPAR
                                                    </button>
                                                ` : `
                                                    <div style="font-size: 6px; color: #666;">Vazio</div>
                                                `}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>

                            <!-- Invent√°rio de Equipamentos -->
                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: #f1c40f; margin-bottom: 10px;">INVENT√ÅRIO</h3>
                                <div style="max-height: 200px; overflow-y: auto;">
                                    ${inventory.filter(item => item.slot).length > 0 ? inventory.filter(item => item.slot).map((item, index) => {
                                        const slotInfo = EQUIPMENT_SLOTS[item.slot];
                                        const isEquipped = equipment[item.slot]?.id === item.id;
                                        return `
                                            <div style="
                                                border: 1px solid ${RARITY_COLORS[item.rarity]};
                                                border-radius: 6px;
                                                padding: 8px;
                                                margin-bottom: 8px;
                                                background: ${isEquipped ? RARITY_COLORS[item.rarity] + '20' : '#111'};
                                                opacity: ${isEquipped ? 0.6 : 1};
                                            ">
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <div>
                                                        <div style="font-size: 8px; color: ${RARITY_COLORS[item.rarity]}; font-weight: bold;">
                                                            ${item.name}
                                                        </div>
                                                        <div style="font-size: 6px; color: #999;">
                                                            ${slotInfo.icon} ${slotInfo.name} | 
                                                            ${item.stats.atk > 0 ? `ATK+${item.stats.atk} ` : ''}
                                                            ${item.stats.def > 0 ? `DEF+${item.stats.def}` : ''}
                                                        </div>
                                                        <div style="font-size: 6px; color: #f1c40f;">
                                                            Valor: ${item.value}G
                                                        </div>
                                                    </div>
                                                    <div style="display: flex; flex-direction: column; gap: 4px;">
                                                        ${!isEquipped ? `
                                                            <button 
                                                                class="btn" 
                                                                style="padding: 4px 8px; font-size: 6px;"
                                                                onclick="game.equipItem('${item.id}', '${item.slot}')"
                                                            >
                                                                EQUIPAR
                                                            </button>
                                                        ` : `
                                                            <div style="font-size: 6px; color: #2ecc71;">Equipado</div>
                                                        `}
                                                        <button 
                                                            class="btn" 
                                                            style="padding: 4px 8px; font-size: 6px; background: #e74c3c;"
                                                            onclick="game.sellItem(${index})"
                                                        >
                                                            VENDER
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('') : '<div style="font-size: 8px; color: #666; text-align: center;">Nenhum equipamento no invent√°rio</div>'}
                                </div>
                            </div>
                            
                            <button class="btn" onclick="game.showScreen('menu')">
                                üîô VOLTAR
                            </button>
                        </div>
                    </div>
                `;
            }

            renderSkillSelection() {
                const { skillChoices, hero } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <div style="text-align: center; margin-bottom: 30px;">
                                <h2 class="text-gold" style="font-size: 18px; margin-bottom: 10px;">
                                    ‚ö° ESCOLHA SUA HABILIDADE
                                </h2>
                                <p style="font-size: 10px; color: #999; margin-bottom: 15px;">
                                    Voc√™ atingiu o n√≠vel ${hero.level}! Escolha uma nova habilidade:
                                </p>
                            </div>

                            <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 30px;">
                                ${skillChoices.map((skill, index) => `
                                    <div style="
                                        width: 140px;
                                        height: 160px;
                                        border: 3px solid ${SKILL_RARITY_COLORS[skill.rarity]};
                                        border-radius: 12px;
                                        display: flex;
                                        flex-direction: column;
                                        align-items: center;
                                        justify-content: center;
                                        background: ${SKILL_RARITY_COLORS[skill.rarity]}20;
                                        cursor: pointer;
                                        transition: all 0.3s;
                                        padding: 10px;
                                    "
                                    onclick="game.chooseSkill('${skill.id}')"
                                    onmouseover="this.style.transform='scale(1.05)'; this.style.background='${SKILL_RARITY_COLORS[skill.rarity]}40';"
                                    onmouseout="this.style.transform='scale(1)'; this.style.background='${SKILL_RARITY_COLORS[skill.rarity]}20';"
                                    >
                                        <div style="font-size: 32px; margin-bottom: 8px;">
                                            ${skill.icon}
                                        </div>
                                        <div style="font-size: 10px; color: ${SKILL_RARITY_COLORS[skill.rarity]}; font-weight: bold; margin-bottom: 4px; text-align: center;">
                                            ${skill.name}
                                        </div>
                                        <div style="font-size: 7px; color: #999; text-align: center; line-height: 1.2;">
                                            ${skill.description}
                                        </div>
                                        <div style="font-size: 6px; color: ${SKILL_TYPES[skill.type].color}; margin-top: 4px;">
                                            ${SKILL_TYPES[skill.type].name}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>

                            <div style="text-align: center; margin-bottom: 20px;">
                                <p style="font-size: 8px; color: #666;">
                                    üí° Cada habilidade tem efeitos √∫nicos em combate
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderSkills() {
                const { unlockedSkills, equippedSkills, skillCooldowns, hero } = this.state;

                return `
                    <div class="container">
                        ${this.renderHeader()}
                        
                        <div class="window">
                            <h2 class="text-gold text-center mb-4">‚ö° HABILIDADES</h2>
                            
                            <!-- Slots Equipados -->
                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: #f1c40f; margin-bottom: 10px;">EQUIPADOS (5/5)</h3>
                                <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px;">
                                    ${equippedSkills.map((skillId, index) => {
                                        if (!skillId) {
                                            return `
                                                <div style="
                                                    border: 2px dashed #666;
                                                    border-radius: 8px;
                                                    padding: 15px;
                                                    text-align: center;
                                                    background: #111;
                                                ">
                                                    <div style="font-size: 24px; color: #666;">üîí</div>
                                                    <div style="font-size: 6px; color: #666;">Slot ${index + 1}</div>
                                                    <div style="font-size: 5px; color: #666;">Vazio</div>
                                                </div>
                                            `;
                                        }
                                        
                                        const skill = SKILLS_DATABASE[skillId];
                                        const cooldown = skillCooldowns[skillId] || 0;
                                        const isOnCooldown = cooldown > 0;
                                        
                                        return `
                                            <div style="
                                                border: 2px solid ${isOnCooldown ? '#666' : SKILL_RARITY_COLORS[skill.rarity]};
                                                border-radius: 8px;
                                                padding: 10px;
                                                text-align: center;
                                                background: ${isOnCooldown ? '#333' : SKILL_RARITY_COLORS[skill.rarity] + '20'};
                                                cursor: ${isOnCooldown ? 'not-allowed' : 'pointer'};
                                                transition: all 0.3s;
                                            "
                                            ${!isOnCooldown ? `onclick="game.useSkill('${skillId}')"` : ''}
                                            ${!isOnCooldown ? `onmouseover="this.style.transform='scale(1.05)'"` : ''}
                                            ${!isOnCooldown ? `onmouseout="this.style.transform='scale(1)'"` : ''}
                                            >
                                                <div style="font-size: 20px; margin-bottom: 5px;">
                                                    ${skill.icon}
                                                </div>
                                                <div style="font-size: 6px; color: ${isOnCooldown ? '#666' : SKILL_RARITY_COLORS[skill.rarity]}; margin-bottom: 3px;">
                                                    ${skill.name}
                                                </div>
                                                <div style="font-size: 5px; color: ${SKILL_TYPES[skill.type].color};">
                                                    ${SKILL_TYPES[skill.type].name}
                                                </div>
                                                ${isOnCooldown ? `
                                                    <div style="font-size: 5px; color: #e74c3c; margin-top: 3px;">
                                                        CD: ${cooldown}
                                                    </div>
                                                ` : `
                                                    <div style="font-size: 5px; color: #2ecc71; margin-top: 3px;">
                                                        Pronto
                                                    </div>
                                                `}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>

                            <!-- Habilidades Desbloqueadas -->
                            <div style="margin-bottom: 20px;">
                                <h3 style="font-size: 12px; color: #f1c40f; margin-bottom: 10px;">
                                    DESBLOQUEADAS (${unlockedSkills.length}/10)
                                </h3>
                                <div style="max-height: 200px; overflow-y: auto;">
                                    ${unlockedSkills.length > 0 ? unlockedSkills.map(skillId => {
                                        const skill = SKILLS_DATABASE[skillId];
                                        const isEquipped = equippedSkills.includes(skillId);
                                        
                                        return `
                                            <div style="
                                                border: 1px solid ${SKILL_RARITY_COLORS[skill.rarity]};
                                                border-radius: 6px;
                                                padding: 8px;
                                                margin-bottom: 8px;
                                                background: ${isEquipped ? SKILL_RARITY_COLORS[skill.rarity] + '20' : '#111'};
                                                opacity: ${isEquipped ? 0.6 : 1};
                                            ">
                                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                                    <div>
                                                        <div style="display: flex; align-items: center; gap: 8px;">
                                                            <div style="font-size: 16px;">${skill.icon}</div>
                                                            <div>
                                                                <div style="font-size: 8px; color: ${SKILL_RARITY_COLORS[skill.rarity]}; font-weight: bold;">
                                                                    ${skill.name}
                                                                </div>
                                                                <div style="font-size: 6px; color: #999;">
                                                                    ${skill.description}
                                                                </div>
                                                                <div style="font-size: 5px; color: ${SKILL_TYPES[skill.type].color};">
                                                                    ${SKILL_TYPES[skill.type].name} | CD: ${skill.cooldown}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div style="display: flex; gap: 4px;">
                                                        ${!isEquipped ? `
                                                            <select 
                                                                style="font-size: 6px; padding: 2px; background: #333; color: #fff; border: 1px solid #666;"
                                                                onchange="game.equipSkill('${skillId}', this.value)"
                                                            >
                                                                <option value="">Equipar</option>
                                                                ${equippedSkills.map((_, index) => 
                                                                    `<option value="${index}">Slot ${index + 1}</option>`
                                                                ).join('')}
                                                            </select>
                                                        ` : `
                                                            <div style="font-size: 6px; color: #2ecc71;">Equipado</div>
                                                        `}
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('') : '<div style="font-size: 8px; color: #666; text-align: center;">Nenhuma habilidade desbloqueada ainda</div>'}
                                </div>
                            </div>
                            
                            <div style="text-align: center; margin-bottom: 20px;">
                                <p style="font-size: 8px; color: #666;">
                                    üí° Desbloqueie mais habilidades subindo de n√≠vel!
                                </p>
                            </div>
                            
                            <button class="btn" onclick="game.showScreen('menu')">
                                üîô VOLTAR
                            </button>
                        </div>
                    </div>
                `;
            }
        }

        // ============================================
        // INITIALIZE GAME
        // ============================================
        const game = new Game();

        // Auto battle interval - otimizado com requestAnimationFrame
        let autoBattleFrame;
        function startAutoBattle() {
            if (autoBattleFrame) cancelAnimationFrame(autoBattleFrame);
            
            function battleLoop() {
                if (game.state.isAutoBattle && game.state.screen === 'battle') {
                    game.autoBattleLoop();
                    autoBattleFrame = requestAnimationFrame(battleLoop);
                }
            }
            
            autoBattleFrame = requestAnimationFrame(battleLoop);
        }
    </script>
</body>
</html>
